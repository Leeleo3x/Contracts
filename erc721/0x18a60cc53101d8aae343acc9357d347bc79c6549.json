{"Runs": "200", "SwarmSource": "bzzr://7f47d5388ed5393a7994fe9382ac1c4e3ac2e7abf322fbd0aa7dee90c1dae7bc", "ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"_interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementsERC721\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"InterfaceId_ERC165\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"revoke\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenTypes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allTokensIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_type\",\"type\":\"uint256\"},{\"name\":\"_oldIssuer\",\"type\":\"address\"},{\"name\":\"_newIssuer\",\"type\":\"address\"}],\"name\":\"transferIssuer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownedTokensIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextTokenId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_type\",\"type\":\"uint256\"},{\"name\":\"_oldAddress\",\"type\":\"address\"},{\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"transferAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_issuer\",\"type\":\"address\"},{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_type\",\"type\":\"uint256\"}],\"name\":\"issueBatch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextTokenType\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenTypeIssuers\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_issuer\",\"type\":\"address\"},{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_type\",\"type\":\"uint256\"}],\"name\":\"issue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenIssuer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenURIPrefix\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokensByType\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_issuer\",\"type\":\"address\"}],\"name\":\"createType\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_tokenURIPrefix\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_issuer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_type\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"TokenTypeCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_issuer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_type\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"TokenIssued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_issuer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_type\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"TokenRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_type\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_oldIssuer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_newIssuer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"IssuanceTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_oldAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_newAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"TransferAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"}]", "Library": "", "CompilerVersion": "v0.4.24+commit.e67f0147", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000011436f696e626173652054726f706869657300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034342540000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002868747470733a2f2f63622d74726f70686965732e6865726f6b756170702e636f6d2f746f6b656e2f000000000000000000000000000000000000000000000000", "SourceCode": "pragma solidity ^0.4.13;\r\n\r\nlibrary AddressUtils {\r\n\r\n  /**\r\n   * Returns whether the target address is a contract\r\n   * @dev This function will return false if invoked during the constructor of a contract,\r\n   * as the code is not actually created until after the constructor finishes.\r\n   * @param _addr address to check\r\n   * @return whether the target address is a contract\r\n   */\r\n  function isContract(address _addr) internal view returns (bool) {\r\n    uint256 size;\r\n    // XXX Currently there is no better way to check if there is a contract in an address\r\n    // than to check the size of the code at that address.\r\n    // See https://ethereum.stackexchange.com/a/14016/36603\r\n    // for more details about how this works.\r\n    // TODO Check this again before the Serenity release, because all addresses will be\r\n    // contracts then.\r\n    // solium-disable-next-line security/no-inline-assembly\r\n    assembly { size := extcodesize(_addr) }\r\n    return size > 0;\r\n  }\r\n\r\n}\r\n\r\ninterface ERC165 {\r\n\r\n  /**\r\n   * @notice Query if a contract implements an interface\r\n   * @param _interfaceId The interface identifier, as specified in ERC-165\r\n   * @dev Interface identification is specified in ERC-165. This function\r\n   * uses less than 30,000 gas.\r\n   */\r\n  function supportsInterface(bytes4 _interfaceId)\r\n    external\r\n    view\r\n    returns (bool);\r\n}\r\n\r\ncontract SupportsInterfaceWithLookup is ERC165 {\r\n\r\n  bytes4 public constant InterfaceId_ERC165 = 0x01ffc9a7;\r\n  /**\r\n   * 0x01ffc9a7 ===\r\n   *   bytes4(keccak256('supportsInterface(bytes4)'))\r\n   */\r\n\r\n  /**\r\n   * @dev a mapping of interface id to whether or not it's supported\r\n   */\r\n  mapping(bytes4 => bool) internal supportedInterfaces;\r\n\r\n  /**\r\n   * @dev A contract implementing SupportsInterfaceWithLookup\r\n   * implement ERC165 itself\r\n   */\r\n  constructor()\r\n    public\r\n  {\r\n    _registerInterface(InterfaceId_ERC165);\r\n  }\r\n\r\n  /**\r\n   * @dev implement supportsInterface(bytes4) using a lookup table\r\n   */\r\n  function supportsInterface(bytes4 _interfaceId)\r\n    external\r\n    view\r\n    returns (bool)\r\n  {\r\n    return supportedInterfaces[_interfaceId];\r\n  }\r\n\r\n  /**\r\n   * @dev private method for registering an interface\r\n   */\r\n  function _registerInterface(bytes4 _interfaceId)\r\n    internal\r\n  {\r\n    require(_interfaceId != 0xffffffff);\r\n    supportedInterfaces[_interfaceId] = true;\r\n  }\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract ERC721Basic is ERC165 {\r\n\r\n  bytes4 internal constant InterfaceId_ERC721 = 0x80ac58cd;\r\n  /*\r\n   * 0x80ac58cd ===\r\n   *   bytes4(keccak256('balanceOf(address)')) ^\r\n   *   bytes4(keccak256('ownerOf(uint256)')) ^\r\n   *   bytes4(keccak256('approve(address,uint256)')) ^\r\n   *   bytes4(keccak256('getApproved(uint256)')) ^\r\n   *   bytes4(keccak256('setApprovalForAll(address,bool)')) ^\r\n   *   bytes4(keccak256('isApprovedForAll(address,address)')) ^\r\n   *   bytes4(keccak256('transferFrom(address,address,uint256)')) ^\r\n   *   bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\r\n   *   bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\r\n   */\r\n\r\n  bytes4 internal constant InterfaceId_ERC721Exists = 0x4f558e79;\r\n  /*\r\n   * 0x4f558e79 ===\r\n   *   bytes4(keccak256('exists(uint256)'))\r\n   */\r\n\r\n  bytes4 internal constant InterfaceId_ERC721Enumerable = 0x780e9d63;\r\n  /**\r\n   * 0x780e9d63 ===\r\n   *   bytes4(keccak256('totalSupply()')) ^\r\n   *   bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^\r\n   *   bytes4(keccak256('tokenByIndex(uint256)'))\r\n   */\r\n\r\n  bytes4 internal constant InterfaceId_ERC721Metadata = 0x5b5e139f;\r\n  /**\r\n   * 0x5b5e139f ===\r\n   *   bytes4(keccak256('name()')) ^\r\n   *   bytes4(keccak256('symbol()')) ^\r\n   *   bytes4(keccak256('tokenURI(uint256)'))\r\n   */\r\n\r\n  event Transfer(\r\n    address indexed _from,\r\n    address indexed _to,\r\n    uint256 indexed _tokenId\r\n  );\r\n  event Approval(\r\n    address indexed _owner,\r\n    address indexed _approved,\r\n    uint256 indexed _tokenId\r\n  );\r\n  event ApprovalForAll(\r\n    address indexed _owner,\r\n    address indexed _operator,\r\n    bool _approved\r\n  );\r\n\r\n  function balanceOf(address _owner) public view returns (uint256 _balance);\r\n  function ownerOf(uint256 _tokenId) public view returns (address _owner);\r\n  function exists(uint256 _tokenId) public view returns (bool _exists);\r\n\r\n  function approve(address _to, uint256 _tokenId) public;\r\n  function getApproved(uint256 _tokenId)\r\n    public view returns (address _operator);\r\n\r\n  function setApprovalForAll(address _operator, bool _approved) public;\r\n  function isApprovedForAll(address _owner, address _operator)\r\n    public view returns (bool);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _tokenId) public;\r\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId)\r\n    public;\r\n\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes _data\r\n  )\r\n    public;\r\n}\r\n\r\ncontract ERC721Enumerable is ERC721Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function tokenOfOwnerByIndex(\r\n    address _owner,\r\n    uint256 _index\r\n  )\r\n    public\r\n    view\r\n    returns (uint256 _tokenId);\r\n\r\n  function tokenByIndex(uint256 _index) public view returns (uint256);\r\n}\r\n\r\ncontract ERC721Metadata is ERC721Basic {\r\n  function name() external view returns (string _name);\r\n  function symbol() external view returns (string _symbol);\r\n  function tokenURI(uint256 _tokenId) public view returns (string);\r\n}\r\n\r\ncontract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata {\r\n}\r\n\r\ncontract ERC721BasicToken is SupportsInterfaceWithLookup, ERC721Basic {\r\n\r\n  using SafeMath for uint256;\r\n  using AddressUtils for address;\r\n\r\n  // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n  // which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\r\n  bytes4 private constant ERC721_RECEIVED = 0x150b7a02;\r\n\r\n  // Mapping from token ID to owner\r\n  mapping (uint256 => address) internal tokenOwner;\r\n\r\n  // Mapping from token ID to approved address\r\n  mapping (uint256 => address) internal tokenApprovals;\r\n\r\n  // Mapping from owner to number of owned token\r\n  mapping (address => uint256) internal ownedTokensCount;\r\n\r\n  // Mapping from owner to operator approvals\r\n  mapping (address => mapping (address => bool)) internal operatorApprovals;\r\n\r\n  constructor()\r\n    public\r\n  {\r\n    // register the supported interfaces to conform to ERC721 via ERC165\r\n    _registerInterface(InterfaceId_ERC721);\r\n    _registerInterface(InterfaceId_ERC721Exists);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the balance of the specified address\r\n   * @param _owner address to query the balance of\r\n   * @return uint256 representing the amount owned by the passed address\r\n   */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    require(_owner != address(0));\r\n    return ownedTokensCount[_owner];\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the owner of the specified token ID\r\n   * @param _tokenId uint256 ID of the token to query the owner of\r\n   * @return owner address currently marked as the owner of the given token ID\r\n   */\r\n  function ownerOf(uint256 _tokenId) public view returns (address) {\r\n    address owner = tokenOwner[_tokenId];\r\n    require(owner != address(0));\r\n    return owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns whether the specified token exists\r\n   * @param _tokenId uint256 ID of the token to query the existence of\r\n   * @return whether the token exists\r\n   */\r\n  function exists(uint256 _tokenId) public view returns (bool) {\r\n    address owner = tokenOwner[_tokenId];\r\n    return owner != address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Approves another address to transfer the given token ID\r\n   * The zero address indicates there is no approved address.\r\n   * There can only be one approved address per token at a given time.\r\n   * Can only be called by the token owner or an approved operator.\r\n   * @param _to address to be approved for the given token ID\r\n   * @param _tokenId uint256 ID of the token to be approved\r\n   */\r\n  function approve(address _to, uint256 _tokenId) public {\r\n    address owner = ownerOf(_tokenId);\r\n    require(_to != owner);\r\n    require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\r\n\r\n    tokenApprovals[_tokenId] = _to;\r\n    emit Approval(owner, _to, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the approved address for a token ID, or zero if no address set\r\n   * @param _tokenId uint256 ID of the token to query the approval of\r\n   * @return address currently approved for the given token ID\r\n   */\r\n  function getApproved(uint256 _tokenId) public view returns (address) {\r\n    return tokenApprovals[_tokenId];\r\n  }\r\n\r\n  /**\r\n   * @dev Sets or unsets the approval of a given operator\r\n   * An operator is allowed to transfer all tokens of the sender on their behalf\r\n   * @param _to operator address to set the approval\r\n   * @param _approved representing the status of the approval to be set\r\n   */\r\n  function setApprovalForAll(address _to, bool _approved) public {\r\n    require(_to != msg.sender);\r\n    operatorApprovals[msg.sender][_to] = _approved;\r\n    emit ApprovalForAll(msg.sender, _to, _approved);\r\n  }\r\n\r\n  /**\r\n   * @dev Tells whether an operator is approved by a given owner\r\n   * @param _owner owner address which you want to query the approval of\r\n   * @param _operator operator address which you want to query the approval of\r\n   * @return bool whether the given operator is approved by the given owner\r\n   */\r\n  function isApprovedForAll(\r\n    address _owner,\r\n    address _operator\r\n  )\r\n    public\r\n    view\r\n    returns (bool)\r\n  {\r\n    return operatorApprovals[_owner][_operator];\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers the ownership of a given token ID to another address\r\n   * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\r\n   * Requires the msg sender to be the owner, approved, or operator\r\n   * @param _from current owner of the token\r\n   * @param _to address to receive the ownership of the given token ID\r\n   * @param _tokenId uint256 ID of the token to be transferred\r\n  */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    public\r\n  {\r\n    require(isApprovedOrOwner(msg.sender, _tokenId));\r\n    require(_from != address(0));\r\n    require(_to != address(0));\r\n\r\n    clearApproval(_from, _tokenId);\r\n    removeTokenFrom(_from, _tokenId);\r\n    addTokenTo(_to, _tokenId);\r\n\r\n    emit Transfer(_from, _to, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Safely transfers the ownership of a given token ID to another address\r\n   * If the target address is a contract, it must implement `onERC721Received`,\r\n   * which is called upon a safe transfer, and return the magic value\r\n   * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n   * the transfer is reverted.\r\n   *\r\n   * Requires the msg sender to be the owner, approved, or operator\r\n   * @param _from current owner of the token\r\n   * @param _to address to receive the ownership of the given token ID\r\n   * @param _tokenId uint256 ID of the token to be transferred\r\n  */\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    public\r\n  {\r\n    // solium-disable-next-line arg-overflow\r\n    safeTransferFrom(_from, _to, _tokenId, \"\");\r\n  }\r\n\r\n  /**\r\n   * @dev Safely transfers the ownership of a given token ID to another address\r\n   * If the target address is a contract, it must implement `onERC721Received`,\r\n   * which is called upon a safe transfer, and return the magic value\r\n   * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n   * the transfer is reverted.\r\n   * Requires the msg sender to be the owner, approved, or operator\r\n   * @param _from current owner of the token\r\n   * @param _to address to receive the ownership of the given token ID\r\n   * @param _tokenId uint256 ID of the token to be transferred\r\n   * @param _data bytes data to send along with a safe transfer check\r\n   */\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes _data\r\n  )\r\n    public\r\n  {\r\n    transferFrom(_from, _to, _tokenId);\r\n    // solium-disable-next-line arg-overflow\r\n    require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns whether the given spender can transfer a given token ID\r\n   * @param _spender address of the spender to query\r\n   * @param _tokenId uint256 ID of the token to be transferred\r\n   * @return bool whether the msg.sender is approved for the given token ID,\r\n   *  is an operator of the owner, or is the owner of the token\r\n   */\r\n  function isApprovedOrOwner(\r\n    address _spender,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    address owner = ownerOf(_tokenId);\r\n    // Disable solium check because of\r\n    // https://github.com/duaraghav8/Solium/issues/175\r\n    // solium-disable-next-line operator-whitespace\r\n    return (\r\n      _spender == owner ||\r\n      getApproved(_tokenId) == _spender ||\r\n      isApprovedForAll(owner, _spender)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to mint a new token\r\n   * Reverts if the given token ID already exists\r\n   * @param _to The address that will own the minted token\r\n   * @param _tokenId uint256 ID of the token to be minted by the msg.sender\r\n   */\r\n  function _mint(address _to, uint256 _tokenId) internal {\r\n    require(_to != address(0));\r\n    addTokenTo(_to, _tokenId);\r\n    emit Transfer(address(0), _to, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to burn a specific token\r\n   * Reverts if the token does not exist\r\n   * @param _tokenId uint256 ID of the token being burned by the msg.sender\r\n   */\r\n  function _burn(address _owner, uint256 _tokenId) internal {\r\n    clearApproval(_owner, _tokenId);\r\n    removeTokenFrom(_owner, _tokenId);\r\n    emit Transfer(_owner, address(0), _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to clear current approval of a given token ID\r\n   * Reverts if the given address is not indeed the owner of the token\r\n   * @param _owner owner of the token\r\n   * @param _tokenId uint256 ID of the token to be transferred\r\n   */\r\n  function clearApproval(address _owner, uint256 _tokenId) internal {\r\n    require(ownerOf(_tokenId) == _owner);\r\n    if (tokenApprovals[_tokenId] != address(0)) {\r\n      tokenApprovals[_tokenId] = address(0);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to add a token ID to the list of a given address\r\n   * @param _to address representing the new owner of the given token ID\r\n   * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n   */\r\n  function addTokenTo(address _to, uint256 _tokenId) internal {\r\n    require(tokenOwner[_tokenId] == address(0));\r\n    tokenOwner[_tokenId] = _to;\r\n    ownedTokensCount[_to] = ownedTokensCount[_to].add(1);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to remove a token ID from the list of a given address\r\n   * @param _from address representing the previous owner of the given token ID\r\n   * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n   */\r\n  function removeTokenFrom(address _from, uint256 _tokenId) internal {\r\n    require(ownerOf(_tokenId) == _from);\r\n    ownedTokensCount[_from] = ownedTokensCount[_from].sub(1);\r\n    tokenOwner[_tokenId] = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to invoke `onERC721Received` on a target address\r\n   * The call is not executed if the target address is not a contract\r\n   * @param _from address representing the previous owner of the given token ID\r\n   * @param _to target address that will receive the tokens\r\n   * @param _tokenId uint256 ID of the token to be transferred\r\n   * @param _data bytes optional data to send along with the call\r\n   * @return whether the call correctly returned the expected magic value\r\n   */\r\n  function checkAndCallSafeTransfer(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes _data\r\n  )\r\n    internal\r\n    returns (bool)\r\n  {\r\n    if (!_to.isContract()) {\r\n      return true;\r\n    }\r\n    bytes4 retval = ERC721Receiver(_to).onERC721Received(\r\n      msg.sender, _from, _tokenId, _data);\r\n    return (retval == ERC721_RECEIVED);\r\n  }\r\n}\r\n\r\ncontract Trophy is SupportsInterfaceWithLookup, ERC721BasicToken, ERC721 {\r\n\r\n    // Use solidity-stringutils\r\n    using strings for *;\r\n\r\n    // Token name\r\n    string internal name_;\r\n\r\n    // Token symbol\r\n    string internal symbol_;\r\n\r\n    // Mapping from owner to list of owned token IDs\r\n    mapping(address => uint256[]) public ownedTokens;\r\n\r\n    // Mapping from token ID to index of the owner tokens list\r\n    mapping(uint256 => uint256) public ownedTokensIndex;\r\n\r\n    // Array with all token ids, used for enumeration\r\n    uint256[] public allTokens;\r\n\r\n    // Mapping from token id to position in the allTokens array\r\n    mapping(uint256 => uint256) public allTokensIndex;\r\n\r\n    // Super administrator for this contract\r\n    address public manager;\r\n\r\n    // Next token identifier\r\n    uint256 public nextTokenId = 1;\r\n\r\n    // Next token type\r\n    uint256 public nextTokenType = 1;\r\n\r\n    // URI prefix for all token URIs\r\n    string public tokenURIPrefix;\r\n\r\n    // Types associated with tokens\r\n    mapping (uint256 => uint256) public tokenTypes;\r\n\r\n    // Owners of types\r\n    mapping (uint256 => address) public tokenTypeIssuers;\r\n\r\n    // A mapping of token id to issuer\r\n    mapping (uint256 => address) public tokenIssuer;\r\n\r\n    // A map of tokens by a type\r\n    mapping (uint256 => uint256[]) public tokensByType;\r\n\r\n    // Event emitted upon token type creation\r\n    event TokenTypeCreated(\r\n        address _issuer,\r\n        uint256 _type,\r\n        uint256 _timestamp\r\n    );\r\n\r\n    // Event emmited upon token is issued\r\n    event TokenIssued(\r\n        address _issuer,\r\n        address _owner,\r\n        uint256 _type,\r\n        uint256 _tokenId,\r\n        uint256 _timestamp\r\n    );\r\n\r\n    // Event emmited upon token is revoked\r\n    event TokenRevoked(\r\n        address _issuer,\r\n        address _owner,\r\n        uint256 _type,\r\n        uint256 _tokenId,\r\n        uint256 _timestamp\r\n    );\r\n\r\n    // Event emmited upon token issuance is transferred\r\n    event IssuanceTransferred(\r\n        uint256 _type,\r\n        address _oldIssuer,\r\n        address _newIssuer,\r\n        uint256 _timestamp\r\n    );\r\n\r\n    // Event emmited upon transfer all tokens\r\n    event TransferAll(\r\n        address _oldAddress,\r\n        address _newAddress,\r\n        uint256 _timestamp\r\n    );\r\n\r\n    /**\r\n    * @dev Constructor function\r\n    */\r\n    constructor(string _name, string _symbol, string _tokenURIPrefix) public {\r\n        name_ = _name;\r\n        symbol_ = _symbol;\r\n        manager = msg.sender;\r\n        tokenURIPrefix = _tokenURIPrefix;\r\n\r\n        // register the supported interfaces to conform to ERC721 via ERC165\r\n        _registerInterface(InterfaceId_ERC721Enumerable);\r\n        _registerInterface(InterfaceId_ERC721Metadata);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token name\r\n     * @return string representing the token name\r\n     */\r\n    function name() external view returns (string) {\r\n        return name_;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token symbol\r\n     * @return string representing the token symbol\r\n     */\r\n    function symbol() external view returns (string) {\r\n        return symbol_;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an URI for a given token ID\r\n     * Throws if the token ID does not exist. May return an empty string.\r\n     * @param _tokenId uint256 ID of the token to query\r\n     */\r\n    function tokenURI(uint256 _tokenId) public view returns (string) {\r\n        require(tokenOwner[_tokenId] != address(0));\r\n        return tokenURIPrefix.toSlice().concat(uint2str(_tokenId).toSlice());\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token ID at a given index of the tokens list of the requested owner\r\n     * @param _owner address owning the tokens list to be accessed\r\n     * @param _index uint256 representing the index to be accessed of the requested tokens list\r\n     * @return uint256 token ID at the given index of the tokens list owned by the requested address\r\n     */\r\n    function tokenOfOwnerByIndex(\r\n        address _owner,\r\n        uint256 _index\r\n    )\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        require(_index < balanceOf(_owner));\r\n        return ownedTokens[_owner][_index];\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the total amount of tokens stored by the contract\r\n    * @return uint256 representing the total amount of tokens\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return allTokens.length;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the token ID at a given index of all the tokens in this contract\r\n    * Reverts if the index is greater or equal to the total number of tokens\r\n    * @param _index uint256 representing the index to be accessed of the tokens list\r\n    * @return uint256 token ID at the given index of the tokens list\r\n     */\r\n    function tokenByIndex(uint256 _index) public view returns (uint256) {\r\n        require(_index < totalSupply());\r\n        return allTokens[_index];\r\n    }\r\n\r\n    /**\r\n     * @dev Implements ERC 721\r\n     */\r\n    function implementsERC721() public pure returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Creates a new token type\r\n    * @param _issuer address of the new token type issuer\r\n    */\r\n    function createType(address _issuer) external {\r\n        require(\r\n            msg.sender == manager || msg.sender == _issuer,\r\n            \"Only managers can issue trophies on behalf of others.\"\r\n        );\r\n\r\n        tokenTypeIssuers[nextTokenType] = _issuer;\r\n        emit TokenTypeCreated(_issuer, nextTokenType, block.timestamp); // solium-disable-line security/no-block-members\r\n        nextTokenType++;\r\n    }\r\n\r\n    /**\r\n     * @dev Issues a new token\r\n     * @param _issuer address of the new token type issuer\r\n     */\r\n    function issue(address _issuer, address _owner, uint256 _type) public {\r\n        require(\r\n            (msg.sender == manager && tokenTypeIssuers[_type] != 0) || (msg.sender == _issuer && tokenTypeIssuers[_type] == _issuer), // solium-disable-line indentation\r\n            \"Only managers and issuers can issue trophies.\"\r\n        );\r\n\r\n        _mint(_owner, nextTokenId);\r\n        tokenTypes[nextTokenId] = _type;\r\n        tokensByType[_type].push(nextTokenId);\r\n\r\n        emit TokenIssued(\r\n            _issuer,\r\n            _owner,\r\n            _type,\r\n            nextTokenId,\r\n            block.timestamp // solium-disable-line security/no-block-members\r\n        );\r\n\r\n        nextTokenId++;\r\n    }\r\n\r\n    /**\r\n     * @dev issues the same token to many addresses\r\n     * @param _issuer address of the new token type issuer\r\n     * @param _owners an array of addresses of token holders\r\n     * @param _type type of an token\r\n     */\r\n    function issueBatch(address _issuer, address[] _owners, uint256 _type) external {\r\n        require(_owners.length > 0, \"Owners cannot be empty\");\r\n\r\n        for (uint256 index = 0; index < _owners.length; index++ ) {\r\n            issue(_issuer, _owners[index], _type);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Revokes issuance permissions to another address\r\n     */\r\n    function revoke(uint256 _tokenId) external {\r\n        address owner = tokenOwner[_tokenId];\r\n        uint256 tokenType = tokenTypes[_tokenId];\r\n        address issuer = tokenTypeIssuers[tokenType];\r\n\r\n        require(\r\n            msg.sender == manager || msg.sender == issuer || msg.sender == owner,\r\n            \"Only managers, owners, and issuers of the trophy can revoke them.\"\r\n        );\r\n\r\n        _burn(owner, _tokenId);\r\n\r\n        uint256 tokenIndex;\r\n        bool tokenFound;\r\n        for (uint256 i = 0; i < tokensByType[tokenType].length; i++) {\r\n            if (tokensByType[tokenType][i] == _tokenId) {\r\n                tokenIndex = i;\r\n                tokenFound = true;\r\n                break;\r\n            }\r\n        }\r\n        require(tokenFound, \"token not found\");\r\n\r\n        uint256 lastTokenIndex = tokensByType[tokenType].length.sub(1);\r\n        uint256 lastToken = tokensByType[tokenType][lastTokenIndex];\r\n\r\n        tokensByType[tokenType][tokenIndex] = lastToken;\r\n        tokensByType[tokenType][lastTokenIndex] = 0;\r\n\r\n        emit TokenRevoked(\r\n            issuer,\r\n            owner,\r\n            tokenType,\r\n            _tokenId,\r\n            block.timestamp // solium-disable-line security/no-block-members\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev Transfers issuance permissions to another address\r\n    */\r\n    function transferIssuer(uint256 _type, address _oldIssuer, address _newIssuer) external {\r\n        require(\r\n            msg.sender == manager || (msg.sender == _oldIssuer && tokenTypeIssuers[_type] == _oldIssuer),\r\n            \"Only managers and issuers can transfer issuance of trophies.\"\r\n        );\r\n\r\n        tokenTypeIssuers[_type] = _newIssuer;\r\n        emit IssuanceTransferred(\r\n            _type,\r\n            _oldIssuer,\r\n            _newIssuer,\r\n            block.timestamp // solium-disable-line security/no-block-members\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev Transfers all tokens to a new address\r\n     */\r\n    function transferAll(uint256 _type, address _oldAddress, address _newAddress) external {\r\n        require(\r\n            msg.sender == manager || (msg.sender == _oldAddress && tokenTypeIssuers[_type] == _oldAddress),\r\n            \"Only managers and issuers can transfer all tokens to a new address.\"\r\n        );\r\n\r\n        for (uint256 i = 0; i < ownedTokens[_oldAddress].length; i++) {\r\n            uint256 token = ownedTokens[_oldAddress][i];\r\n            removeTokenFrom(_oldAddress, token);\r\n            addTokenTo(_newAddress, token);\r\n        }\r\n        emit TransferAll(_oldAddress, _newAddress, block.timestamp); // solium-disable-line security/no-block-members\r\n    }\r\n\r\n    /**\r\n     * @dev Restrict all transfers\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) public {\r\n        require(false, \"Transfers of trophies are not allowed.\");\r\n    }\r\n\r\n    /**\r\n     * @dev Restrict all transfers\r\n     */\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) public {\r\n        require(false, \"Transfers of trophies are not allowed.\");\r\n    }\r\n\r\n    /**\r\n     * @dev Restrict all transfers\r\n     */\r\n    function setApprovalForAll(address _to, bool _approved) public {\r\n        require(false, \"Transfers of trophies are not allowed.\");\r\n    }\r\n\r\n    /**\r\n     * @dev Restrict all transfers\r\n     */\r\n    function approve(address _to, uint256 _tokenId) public {\r\n        require(false, \"Transfers of trophies are not allowed.\");\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to mint a new token\r\n     * Reverts if the given token ID already exists\r\n     * @param _to address the beneficiary that will own the minted token\r\n     * @param _tokenId uint256 ID of the token to be minted by the msg.sender\r\n     */\r\n    function _mint(address _to, uint256 _tokenId) internal {\r\n        super._mint(_to, _tokenId);\r\n\r\n        allTokensIndex[_tokenId] = allTokens.length;\r\n        allTokens.push(_tokenId);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to burn a specific token\r\n    * Reverts if the token does not exist\r\n        * @param _owner owner of the token to burn\r\n        * @param _tokenId uint256 ID of the token being burned by the msg.sender\r\n     */\r\n    function _burn(address _owner, uint256 _tokenId) internal {\r\n        super._burn(_owner, _tokenId);\r\n\r\n        // Reorg all tokens array\r\n        uint256 tokenIndex = allTokensIndex[_tokenId];\r\n        uint256 lastTokenIndex = allTokens.length.sub(1);\r\n        uint256 lastToken = allTokens[lastTokenIndex];\r\n\r\n        allTokens[tokenIndex] = lastToken;\r\n        allTokens[lastTokenIndex] = 0;\r\n\r\n        allTokens.length--;\r\n        allTokensIndex[_tokenId] = 0;\r\n        allTokensIndex[lastToken] = tokenIndex;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to add a token ID to the list of a given address\r\n    * @param _to address representing the new owner of the given token ID\r\n    * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n     */\r\n    function addTokenTo(address _to, uint256 _tokenId) internal {\r\n        super.addTokenTo(_to, _tokenId);\r\n        uint256 length = ownedTokens[_to].length;\r\n        ownedTokens[_to].push(_tokenId);\r\n        ownedTokensIndex[_tokenId] = length;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to remove a token ID from the list of a given address\r\n    * @param _from address representing the previous owner of the given token ID\r\n    * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n     */\r\n    function removeTokenFrom(address _from, uint256 _tokenId) internal {\r\n        super.removeTokenFrom(_from, _tokenId);\r\n\r\n        // To prevent a gap in the array, we store the last token in the index of the token to delete, and\r\n        // then delete the last slot.\r\n        uint256 tokenIndex = ownedTokensIndex[_tokenId];\r\n        uint256 lastTokenIndex = ownedTokens[_from].length.sub(1);\r\n        uint256 lastToken = ownedTokens[_from][lastTokenIndex];\r\n\r\n        ownedTokens[_from][tokenIndex] = lastToken;\r\n        // This also deletes the contents at the last position of the array\r\n        ownedTokens[_from].length--;\r\n\r\n        // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to\r\n        // be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping\r\n        // the lastToken to the first position, and then dropping the element placed in the last position of the list\r\n\r\n        ownedTokensIndex[_tokenId] = 0;\r\n        ownedTokensIndex[lastToken] = tokenIndex;\r\n    }\r\n\r\n    /**\r\n    * @dev Converts a uint256 to a decimal string\r\n    */\r\n    function uint2str(uint256 i) internal pure returns (string) {\r\n        if (i == 0) return \"0\";\r\n        uint256 j = i;\r\n        uint256 m = i;\r\n        uint256 length;\r\n        while (j != 0){\r\n            length++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(length);\r\n        uint256 k = length - 1;\r\n        while (m != 0){\r\n            bstr[k--] = byte(48 + m % 10);\r\n            m /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n}\r\n\r\ncontract ERC721Receiver {\r\n  /**\r\n   * @dev Magic value to be returned upon successful reception of an NFT\r\n   *  Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`,\r\n   *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\r\n   */\r\n  bytes4 internal constant ERC721_RECEIVED = 0x150b7a02;\r\n\r\n  /**\r\n   * @notice Handle the receipt of an NFT\r\n   * @dev The ERC721 smart contract calls this function on the recipient\r\n   * after a `safetransfer`. This function MAY throw to revert and reject the\r\n   * transfer. Return of other than the magic value MUST result in the\r\n   * transaction being reverted.\r\n   * Note: the contract address is always the message sender.\r\n   * @param _operator The address which called `safeTransferFrom` function\r\n   * @param _from The address which previously owned the token\r\n   * @param _tokenId The NFT identifier which is being transferred\r\n   * @param _data Additional data with no specified format\r\n   * @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n   */\r\n  function onERC721Received(\r\n    address _operator,\r\n    address _from,\r\n    uint256 _tokenId,\r\n    bytes _data\r\n  )\r\n    public\r\n    returns(bytes4);\r\n}\r\n\r\nlibrary strings {\r\n    struct slice {\r\n        uint _len;\r\n        uint _ptr;\r\n    }\r\n\r\n    function memcpy(uint dest, uint src, uint len) private pure {\r\n        // Copy word-length chunks while possible\r\n        for(; len >= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint mask = 256 ** (32 - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a slice containing the entire string.\r\n     * @param self The string to make a slice from.\r\n     * @return A newly allocated slice containing the entire string.\r\n     */\r\n    function toSlice(string memory self) internal pure returns (slice memory) {\r\n        uint ptr;\r\n        assembly {\r\n            ptr := add(self, 0x20)\r\n        }\r\n        return slice(bytes(self).length, ptr);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the length of a null-terminated bytes32 string.\r\n     * @param self The value to find the length of.\r\n     * @return The length of the string, from 0 to 32.\r\n     */\r\n    function len(bytes32 self) internal pure returns (uint) {\r\n        uint ret;\r\n        if (self == 0)\r\n            return 0;\r\n        if (self & 0xffffffffffffffffffffffffffffffff == 0) {\r\n            ret += 16;\r\n            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\r\n        }\r\n        if (self & 0xffffffffffffffff == 0) {\r\n            ret += 8;\r\n            self = bytes32(uint(self) / 0x10000000000000000);\r\n        }\r\n        if (self & 0xffffffff == 0) {\r\n            ret += 4;\r\n            self = bytes32(uint(self) / 0x100000000);\r\n        }\r\n        if (self & 0xffff == 0) {\r\n            ret += 2;\r\n            self = bytes32(uint(self) / 0x10000);\r\n        }\r\n        if (self & 0xff == 0) {\r\n            ret += 1;\r\n        }\r\n        return 32 - ret;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a slice containing the entire bytes32, interpreted as a\r\n     *      null-terminated utf-8 string.\r\n     * @param self The bytes32 value to convert to a slice.\r\n     * @return A new slice containing the value of the input argument up to the\r\n     *         first null.\r\n     */\r\n    function toSliceB32(bytes32 self) internal pure returns (slice memory ret) {\r\n        // Allocate space for `self` in memory, copy it there, and point ret at it\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(0x40, add(ptr, 0x20))\r\n            mstore(ptr, self)\r\n            mstore(add(ret, 0x20), ptr)\r\n        }\r\n        ret._len = len(self);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a new slice containing the same data as the current slice.\r\n     * @param self The slice to copy.\r\n     * @return A new slice containing the same data as `self`.\r\n     */\r\n    function copy(slice memory self) internal pure returns (slice memory) {\r\n        return slice(self._len, self._ptr);\r\n    }\r\n\r\n    /*\r\n     * @dev Copies a slice to a new string.\r\n     * @param self The slice to copy.\r\n     * @return A newly allocated string containing the slice's text.\r\n     */\r\n    function toString(slice memory self) internal pure returns (string memory) {\r\n        string memory ret = new string(self._len);\r\n        uint retptr;\r\n        assembly { retptr := add(ret, 32) }\r\n\r\n        memcpy(retptr, self._ptr, self._len);\r\n        return ret;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the length in runes of the slice. Note that this operation\r\n     *      takes time proportional to the length of the slice; avoid using it\r\n     *      in loops, and call `slice.empty()` if you only need to know whether\r\n     *      the slice is empty or not.\r\n     * @param self The slice to operate on.\r\n     * @return The length of the slice in runes.\r\n     */\r\n    function len(slice memory self) internal pure returns (uint l) {\r\n        // Starting at ptr-31 means the LSB will be the byte we care about\r\n        uint ptr = self._ptr - 31;\r\n        uint end = ptr + self._len;\r\n        for (l = 0; ptr < end; l++) {\r\n            uint8 b;\r\n            assembly { b := and(mload(ptr), 0xFF) }\r\n            if (b < 0x80) {\r\n                ptr += 1;\r\n            } else if(b < 0xE0) {\r\n                ptr += 2;\r\n            } else if(b < 0xF0) {\r\n                ptr += 3;\r\n            } else if(b < 0xF8) {\r\n                ptr += 4;\r\n            } else if(b < 0xFC) {\r\n                ptr += 5;\r\n            } else {\r\n                ptr += 6;\r\n            }\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns true if the slice is empty (has a length of 0).\r\n     * @param self The slice to operate on.\r\n     * @return True if the slice is empty, False otherwise.\r\n     */\r\n    function empty(slice memory self) internal pure returns (bool) {\r\n        return self._len == 0;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a positive number if `other` comes lexicographically after\r\n     *      `self`, a negative number if it comes before, or zero if the\r\n     *      contents of the two slices are equal. Comparison is done per-rune,\r\n     *      on unicode codepoints.\r\n     * @param self The first slice to compare.\r\n     * @param other The second slice to compare.\r\n     * @return The result of the comparison.\r\n     */\r\n    function compare(slice memory self, slice memory other) internal pure returns (int) {\r\n        uint shortest = self._len;\r\n        if (other._len < self._len)\r\n            shortest = other._len;\r\n\r\n        uint selfptr = self._ptr;\r\n        uint otherptr = other._ptr;\r\n        for (uint idx = 0; idx < shortest; idx += 32) {\r\n            uint a;\r\n            uint b;\r\n            assembly {\r\n                a := mload(selfptr)\r\n                b := mload(otherptr)\r\n            }\r\n            if (a != b) {\r\n                // Mask out irrelevant bytes and check again\r\n                uint256 mask = uint256(-1); // 0xffff...\r\n                if(shortest < 32) {\r\n                  mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\r\n                }\r\n                uint256 diff = (a & mask) - (b & mask);\r\n                if (diff != 0)\r\n                    return int(diff);\r\n            }\r\n            selfptr += 32;\r\n            otherptr += 32;\r\n        }\r\n        return int(self._len) - int(other._len);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns true if the two slices contain the same text.\r\n     * @param self The first slice to compare.\r\n     * @param self The second slice to compare.\r\n     * @return True if the slices are equal, false otherwise.\r\n     */\r\n    function equals(slice memory self, slice memory other) internal pure returns (bool) {\r\n        return compare(self, other) == 0;\r\n    }\r\n\r\n    /*\r\n     * @dev Extracts the first rune in the slice into `rune`, advancing the\r\n     *      slice to point to the next rune and returning `self`.\r\n     * @param self The slice to operate on.\r\n     * @param rune The slice that will contain the first rune.\r\n     * @return `rune`.\r\n     */\r\n    function nextRune(slice memory self, slice memory rune) internal pure returns (slice memory) {\r\n        rune._ptr = self._ptr;\r\n\r\n        if (self._len == 0) {\r\n            rune._len = 0;\r\n            return rune;\r\n        }\r\n\r\n        uint l;\r\n        uint b;\r\n        // Load the first byte of the rune into the LSBs of b\r\n        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\r\n        if (b < 0x80) {\r\n            l = 1;\r\n        } else if(b < 0xE0) {\r\n            l = 2;\r\n        } else if(b < 0xF0) {\r\n            l = 3;\r\n        } else {\r\n            l = 4;\r\n        }\r\n\r\n        // Check for truncated codepoints\r\n        if (l > self._len) {\r\n            rune._len = self._len;\r\n            self._ptr += self._len;\r\n            self._len = 0;\r\n            return rune;\r\n        }\r\n\r\n        self._ptr += l;\r\n        self._len -= l;\r\n        rune._len = l;\r\n        return rune;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the first rune in the slice, advancing the slice to point\r\n     *      to the next rune.\r\n     * @param self The slice to operate on.\r\n     * @return A slice containing only the first rune from `self`.\r\n     */\r\n    function nextRune(slice memory self) internal pure returns (slice memory ret) {\r\n        nextRune(self, ret);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the number of the first codepoint in the slice.\r\n     * @param self The slice to operate on.\r\n     * @return The number of the first codepoint in the slice.\r\n     */\r\n    function ord(slice memory self) internal pure returns (uint ret) {\r\n        if (self._len == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint word;\r\n        uint length;\r\n        uint divisor = 2 ** 248;\r\n\r\n        // Load the rune into the MSBs of b\r\n        assembly { word:= mload(mload(add(self, 32))) }\r\n        uint b = word / divisor;\r\n        if (b < 0x80) {\r\n            ret = b;\r\n            length = 1;\r\n        } else if(b < 0xE0) {\r\n            ret = b & 0x1F;\r\n            length = 2;\r\n        } else if(b < 0xF0) {\r\n            ret = b & 0x0F;\r\n            length = 3;\r\n        } else {\r\n            ret = b & 0x07;\r\n            length = 4;\r\n        }\r\n\r\n        // Check for truncated codepoints\r\n        if (length > self._len) {\r\n            return 0;\r\n        }\r\n\r\n        for (uint i = 1; i < length; i++) {\r\n            divisor = divisor / 256;\r\n            b = (word / divisor) & 0xFF;\r\n            if (b & 0xC0 != 0x80) {\r\n                // Invalid UTF-8 sequence\r\n                return 0;\r\n            }\r\n            ret = (ret * 64) | (b & 0x3F);\r\n        }\r\n\r\n        return ret;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the keccak-256 hash of the slice.\r\n     * @param self The slice to hash.\r\n     * @return The hash of the slice.\r\n     */\r\n    function keccak(slice memory self) internal pure returns (bytes32 ret) {\r\n        assembly {\r\n            ret := keccak256(mload(add(self, 32)), mload(self))\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns true if `self` starts with `needle`.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return True if the slice starts with the provided text, false otherwise.\r\n     */\r\n    function startsWith(slice memory self, slice memory needle) internal pure returns (bool) {\r\n        if (self._len < needle._len) {\r\n            return false;\r\n        }\r\n\r\n        if (self._ptr == needle._ptr) {\r\n            return true;\r\n        }\r\n\r\n        bool equal;\r\n        assembly {\r\n            let length := mload(needle)\r\n            let selfptr := mload(add(self, 0x20))\r\n            let needleptr := mload(add(needle, 0x20))\r\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\r\n        }\r\n        return equal;\r\n    }\r\n\r\n    /*\r\n     * @dev If `self` starts with `needle`, `needle` is removed from the\r\n     *      beginning of `self`. Otherwise, `self` is unmodified.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return `self`\r\n     */\r\n    function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) {\r\n        if (self._len < needle._len) {\r\n            return self;\r\n        }\r\n\r\n        bool equal = true;\r\n        if (self._ptr != needle._ptr) {\r\n            assembly {\r\n                let length := mload(needle)\r\n                let selfptr := mload(add(self, 0x20))\r\n                let needleptr := mload(add(needle, 0x20))\r\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\r\n            }\r\n        }\r\n\r\n        if (equal) {\r\n            self._len -= needle._len;\r\n            self._ptr += needle._len;\r\n        }\r\n\r\n        return self;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns true if the slice ends with `needle`.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return True if the slice starts with the provided text, false otherwise.\r\n     */\r\n    function endsWith(slice memory self, slice memory needle) internal pure returns (bool) {\r\n        if (self._len < needle._len) {\r\n            return false;\r\n        }\r\n\r\n        uint selfptr = self._ptr + self._len - needle._len;\r\n\r\n        if (selfptr == needle._ptr) {\r\n            return true;\r\n        }\r\n\r\n        bool equal;\r\n        assembly {\r\n            let length := mload(needle)\r\n            let needleptr := mload(add(needle, 0x20))\r\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\r\n        }\r\n\r\n        return equal;\r\n    }\r\n\r\n    /*\r\n     * @dev If `self` ends with `needle`, `needle` is removed from the\r\n     *      end of `self`. Otherwise, `self` is unmodified.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return `self`\r\n     */\r\n    function until(slice memory self, slice memory needle) internal pure returns (slice memory) {\r\n        if (self._len < needle._len) {\r\n            return self;\r\n        }\r\n\r\n        uint selfptr = self._ptr + self._len - needle._len;\r\n        bool equal = true;\r\n        if (selfptr != needle._ptr) {\r\n            assembly {\r\n                let length := mload(needle)\r\n                let needleptr := mload(add(needle, 0x20))\r\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\r\n            }\r\n        }\r\n\r\n        if (equal) {\r\n            self._len -= needle._len;\r\n        }\r\n\r\n        return self;\r\n    }\r\n\r\n    // Returns the memory address of the first byte of the first occurrence of\r\n    // `needle` in `self`, or the first byte after `self` if not found.\r\n    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\r\n        uint ptr = selfptr;\r\n        uint idx;\r\n\r\n        if (needlelen <= selflen) {\r\n            if (needlelen <= 32) {\r\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\r\n\r\n                bytes32 needledata;\r\n                assembly { needledata := and(mload(needleptr), mask) }\r\n\r\n                uint end = selfptr + selflen - needlelen;\r\n                bytes32 ptrdata;\r\n                assembly { ptrdata := and(mload(ptr), mask) }\r\n\r\n                while (ptrdata != needledata) {\r\n                    if (ptr >= end)\r\n                        return selfptr + selflen;\r\n                    ptr++;\r\n                    assembly { ptrdata := and(mload(ptr), mask) }\r\n                }\r\n                return ptr;\r\n            } else {\r\n                // For long needles, use hashing\r\n                bytes32 hash;\r\n                assembly { hash := keccak256(needleptr, needlelen) }\r\n\r\n                for (idx = 0; idx <= selflen - needlelen; idx++) {\r\n                    bytes32 testHash;\r\n                    assembly { testHash := keccak256(ptr, needlelen) }\r\n                    if (hash == testHash)\r\n                        return ptr;\r\n                    ptr += 1;\r\n                }\r\n            }\r\n        }\r\n        return selfptr + selflen;\r\n    }\r\n\r\n    // Returns the memory address of the first byte after the last occurrence of\r\n    // `needle` in `self`, or the address of `self` if not found.\r\n    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\r\n        uint ptr;\r\n\r\n        if (needlelen <= selflen) {\r\n            if (needlelen <= 32) {\r\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\r\n\r\n                bytes32 needledata;\r\n                assembly { needledata := and(mload(needleptr), mask) }\r\n\r\n                ptr = selfptr + selflen - needlelen;\r\n                bytes32 ptrdata;\r\n                assembly { ptrdata := and(mload(ptr), mask) }\r\n\r\n                while (ptrdata != needledata) {\r\n                    if (ptr <= selfptr)\r\n                        return selfptr;\r\n                    ptr--;\r\n                    assembly { ptrdata := and(mload(ptr), mask) }\r\n                }\r\n                return ptr + needlelen;\r\n            } else {\r\n                // For long needles, use hashing\r\n                bytes32 hash;\r\n                assembly { hash := keccak256(needleptr, needlelen) }\r\n                ptr = selfptr + (selflen - needlelen);\r\n                while (ptr >= selfptr) {\r\n                    bytes32 testHash;\r\n                    assembly { testHash := keccak256(ptr, needlelen) }\r\n                    if (hash == testHash)\r\n                        return ptr + needlelen;\r\n                    ptr -= 1;\r\n                }\r\n            }\r\n        }\r\n        return selfptr;\r\n    }\r\n\r\n    /*\r\n     * @dev Modifies `self` to contain everything from the first occurrence of\r\n     *      `needle` to the end of the slice. `self` is set to the empty slice\r\n     *      if `needle` is not found.\r\n     * @param self The slice to search and modify.\r\n     * @param needle The text to search for.\r\n     * @return `self`.\r\n     */\r\n    function find(slice memory self, slice memory needle) internal pure returns (slice memory) {\r\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        self._len -= ptr - self._ptr;\r\n        self._ptr = ptr;\r\n        return self;\r\n    }\r\n\r\n    /*\r\n     * @dev Modifies `self` to contain the part of the string from the start of\r\n     *      `self` to the end of the first occurrence of `needle`. If `needle`\r\n     *      is not found, `self` is set to the empty slice.\r\n     * @param self The slice to search and modify.\r\n     * @param needle The text to search for.\r\n     * @return `self`.\r\n     */\r\n    function rfind(slice memory self, slice memory needle) internal pure returns (slice memory) {\r\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        self._len = ptr - self._ptr;\r\n        return self;\r\n    }\r\n\r\n    /*\r\n     * @dev Splits the slice, setting `self` to everything after the first\r\n     *      occurrence of `needle`, and `token` to everything before it. If\r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\r\n     *      and `token` is set to the entirety of `self`.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in `self`.\r\n     * @param token An output parameter to which the first token is written.\r\n     * @return `token`.\r\n     */\r\n    function split(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\r\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        token._ptr = self._ptr;\r\n        token._len = ptr - self._ptr;\r\n        if (ptr == self._ptr + self._len) {\r\n            // Not found\r\n            self._len = 0;\r\n        } else {\r\n            self._len -= token._len + needle._len;\r\n            self._ptr = ptr + needle._len;\r\n        }\r\n        return token;\r\n    }\r\n\r\n    /*\r\n     * @dev Splits the slice, setting `self` to everything after the first\r\n     *      occurrence of `needle`, and returning everything before it. If\r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\r\n     *      and the entirety of `self` is returned.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in `self`.\r\n     * @return The part of `self` up to the first occurrence of `delim`.\r\n     */\r\n    function split(slice memory self, slice memory needle) internal pure returns (slice memory token) {\r\n        split(self, needle, token);\r\n    }\r\n\r\n    /*\r\n     * @dev Splits the slice, setting `self` to everything before the last\r\n     *      occurrence of `needle`, and `token` to everything after it. If\r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\r\n     *      and `token` is set to the entirety of `self`.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in `self`.\r\n     * @param token An output parameter to which the first token is written.\r\n     * @return `token`.\r\n     */\r\n    function rsplit(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\r\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        token._ptr = ptr;\r\n        token._len = self._len - (ptr - self._ptr);\r\n        if (ptr == self._ptr) {\r\n            // Not found\r\n            self._len = 0;\r\n        } else {\r\n            self._len -= token._len + needle._len;\r\n        }\r\n        return token;\r\n    }\r\n\r\n    /*\r\n     * @dev Splits the slice, setting `self` to everything before the last\r\n     *      occurrence of `needle`, and returning everything after it. If\r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\r\n     *      and the entirety of `self` is returned.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in `self`.\r\n     * @return The part of `self` after the last occurrence of `delim`.\r\n     */\r\n    function rsplit(slice memory self, slice memory needle) internal pure returns (slice memory token) {\r\n        rsplit(self, needle, token);\r\n    }\r\n\r\n    /*\r\n     * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`.\r\n     * @param self The slice to search.\r\n     * @param needle The text to search for in `self`.\r\n     * @return The number of occurrences of `needle` found in `self`.\r\n     */\r\n    function count(slice memory self, slice memory needle) internal pure returns (uint cnt) {\r\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;\r\n        while (ptr <= self._ptr + self._len) {\r\n            cnt++;\r\n            ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns True if `self` contains `needle`.\r\n     * @param self The slice to search.\r\n     * @param needle The text to search for in `self`.\r\n     * @return True if `needle` is found in `self`, false otherwise.\r\n     */\r\n    function contains(slice memory self, slice memory needle) internal pure returns (bool) {\r\n        return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a newly allocated string containing the concatenation of\r\n     *      `self` and `other`.\r\n     * @param self The first slice to concatenate.\r\n     * @param other The second slice to concatenate.\r\n     * @return The concatenation of the two strings.\r\n     */\r\n    function concat(slice memory self, slice memory other) internal pure returns (string memory) {\r\n        string memory ret = new string(self._len + other._len);\r\n        uint retptr;\r\n        assembly { retptr := add(ret, 32) }\r\n        memcpy(retptr, self._ptr, self._len);\r\n        memcpy(retptr + self._len, other._ptr, other._len);\r\n        return ret;\r\n    }\r\n\r\n    /*\r\n     * @dev Joins an array of slices, using `self` as a delimiter, returning a\r\n     *      newly allocated string.\r\n     * @param self The delimiter to use.\r\n     * @param parts A list of slices to join.\r\n     * @return A newly allocated string containing all the slices in `parts`,\r\n     *         joined with `self`.\r\n     */\r\n    function join(slice memory self, slice[] memory parts) internal pure returns (string memory) {\r\n        if (parts.length == 0)\r\n            return \"\";\r\n\r\n        uint length = self._len * (parts.length - 1);\r\n        for(uint i = 0; i < parts.length; i++)\r\n            length += parts[i]._len;\r\n\r\n        string memory ret = new string(length);\r\n        uint retptr;\r\n        assembly { retptr := add(ret, 32) }\r\n\r\n        for(i = 0; i < parts.length; i++) {\r\n            memcpy(retptr, parts[i]._ptr, parts[i]._len);\r\n            retptr += parts[i]._len;\r\n            if (i < parts.length - 1) {\r\n                memcpy(retptr, self._ptr, self._len);\r\n                retptr += self._len;\r\n            }\r\n        }\r\n\r\n        return ret;\r\n    }\r\n}", "OptimizationUsed": "0", "ContractName": "Trophy", "ByteCode": "0x6080604052600436106101cd576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806301ffc9a7146101d257806306fdde0314610236578063081812fc146102c6578063095ea7b3146103335780631051db341461038057806318160ddd146103af57806319fa8f50146103da57806320c5429b1461044357806323b872dd146104705780632f745c59146104dd57806333f6832a1461053e57806342842e0e1461057f57806342d8edea146105ec578063481c6a751461062d5780634f558e79146106845780634f6ccce7146106c95780635059fad11461070a578063634282af146107775780636352211e146107b857806370a082311461082557806374e243671461087c57806375794a3c146108bd5780637b16f7a0146108e85780637c948adc1461095557806395d89b41146109ba5780639dfe29b514610a4a578063a22cb46514610a75578063af32f6c814610ac4578063b613999214610b31578063b88d4fde14610b9e578063bc38621214610c51578063c0ac998314610cbe578063c87b56dd14610d4e578063e149f03614610df4578063e223ccec14610e55578063e985e9c514610ea0578063f11079cf14610f1b575b600080fd5b3480156101de57600080fd5b5061021c60048036038101908080357bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19169060200190929190505050610f5e565b604051808215151515815260200191505060405180910390f35b34801561024257600080fd5b5061024b610fc5565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561028b578082015181840152602081019050610270565b50505050905090810190601f1680156102b85780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b3480156102d257600080fd5b506102f160048036038101908080359060200190929190505050611067565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b34801561033f57600080fd5b5061037e600480360381019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803590602001909291905050506110a4565b005b34801561038c57600080fd5b50610395611144565b604051808215151515815260200191505060405180910390f35b3480156103bb57600080fd5b506103c461114d565b6040518082815260200191505060405180910390f35b3480156103e657600080fd5b506103ef61115a565b60405180827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200191505060405180910390f35b34801561044f57600080fd5b5061046e60048036038101908080359060200190929190505050611181565b005b34801561047c57600080fd5b506104db600480360381019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803590602001909291905050506115eb565b005b3480156104e957600080fd5b50610528600480360381019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291908035906020019092919050505061168c565b6040518082815260200191505060405180910390f35b34801561054a57600080fd5b5061056960048036038101908080359060200190929190505050611703565b6040518082815260200191505060405180910390f35b34801561058b57600080fd5b506105ea600480360381019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff1690602001909291908035906020019092919050505061171b565b005b3480156105f857600080fd5b50610617600480360381019080803590602001909291905050506117bc565b6040518082815260200191505060405180910390f35b34801561063957600080fd5b506106426117d4565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b34801561069057600080fd5b506106af600480360381019080803590602001909291905050506117fa565b604051808215151515815260200191505060405180910390f35b3480156106d557600080fd5b506106f46004803603810190808035906020019092919050505061186c565b6040518082815260200191505060405180910390f35b34801561071657600080fd5b5061077560048036038101908080359060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506118a4565b005b34801561078357600080fd5b506107a260048036038101908080359060200190929190505050611b2d565b6040518082815260200191505060405180910390f35b3480156107c457600080fd5b506107e360048036038101908080359060200190929190505050611b50565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b34801561083157600080fd5b50610866600480360381019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050611bce565b6040518082815260200191505060405180910390f35b34801561088857600080fd5b506108a760048036038101908080359060200190929190505050611c52565b6040518082815260200191505060405180910390f35b3480156108c957600080fd5b506108d2611c6a565b6040518082815260200191505060405180910390f35b3480156108f457600080fd5b5061095360048036038101908080359060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050611c70565b005b34801561096157600080fd5b506109b8600480360381019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190820180359060200191909192939192939080359060200190929190505050611f93565b005b3480156109c657600080fd5b506109cf612068565b6040518080602001828103825283818151815260200191508051906020019080838360005b83811015610a0f5780820151818401526020810190506109f4565b50505050905090810190601f168015610a3c5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b348015610a5657600080fd5b50610a5f61210a565b6040518082815260200191505060405180910390f35b348015610a8157600080fd5b50610ac2600480360381019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803515159060200190929190505050612110565b005b348015610ad057600080fd5b50610aef600480360381019080803590602001909291905050506121b0565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b348015610b3d57600080fd5b50610b9c600480360381019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803590602001909291905050506121e3565b005b348015610baa57600080fd5b50610c4f600480360381019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190803590602001908201803590602001908080601f01602080910402602001604051908101604052809392919081815260200183838082843782019150505050505091929192905050506124f1565b005b348015610c5d57600080fd5b50610c7c60048036038101908080359060200190929190505050612519565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b348015610cca57600080fd5b50610cd361254c565b6040518080602001828103825283818151815260200191508051906020019080838360005b83811015610d13578082015181840152602081019050610cf8565b50505050905090810190601f168015610d405780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b348015610d5a57600080fd5b50610d79600480360381019080803590602001909291905050506125ea565b6040518080602001828103825283818151815260200191508051906020019080838360005b83811015610db9578082015181840152602081019050610d9e565b50505050905090810190601f168015610de65780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b348015610e0057600080fd5b50610e3f600480360381019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050612727565b6040518082815260200191505060405180910390f35b348015610e6157600080fd5b50610e8a6004803603810190808035906020019092919080359060200190929190505050612757565b6040518082815260200191505060405180910390f35b348015610eac57600080fd5b50610f01600480360381019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050612787565b604051808215151515815260200191505060405180910390f35b348015610f2757600080fd5b50610f5c600480360381019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919050505061281b565b005b6000806000837bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060009054906101000a900460ff169050919050565b606060058054600181600116156101000203166002900480601f01602080910402602001604051908101604052809291908181526020018280546001816001161561010002031660029004801561105d5780601f106110325761010080835404028352916020019161105d565b820191906000526020600020905b81548152906001019060200180831161104057829003601f168201915b5050505050905090565b60006002600083815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050919050565b60001515611140576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260268152602001807f5472616e7366657273206f662074726f706869657320617265206e6f7420616c81526020017f6c6f7765642e000000000000000000000000000000000000000000000000000081525060400191505060405180910390fd5b5050565b60006001905090565b6000600980549050905090565b6301ffc9a77c01000000000000000000000000000000000000000000000000000000000281565b600080600080600080600080600160008a815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169750600f60008a81526020019081526020016000205496506010600088815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169550600b60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148061129657508573ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16145b806112cc57508773ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16145b151561138c576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260418152602001807f4f6e6c79206d616e61676572732c206f776e6572732c20616e6420697373756581526020017f7273206f66207468652074726f7068792063616e207265766f6b65207468656d81526020017f2e0000000000000000000000000000000000000000000000000000000000000081525060600191505060405180910390fd5b611396888a612a1a565b600092505b6012600088815260200190815260200160002080549050831015611404578860126000898152602001908152602001600020848154811015156113da57fe5b906000526020600020015414156113f75782945060019350611404565b828060010193505061139b565b831515611479576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252600f8152602001807f746f6b656e206e6f7420666f756e64000000000000000000000000000000000081525060200191505060405180910390fd5b6114a36001601260008a815260200190815260200160002080549050612b0190919063ffffffff16565b915060126000888152602001908152602001600020828154811015156114c557fe5b906000526020600020015490508060126000898152602001908152602001600020868154811015156114f357fe5b90600052602060002001819055506000601260008981526020019081526020016000208381548110151561152357fe5b90600052602060002001819055507ff200eb5cb6f07f53288208a4a36caec8711fe0c5e2e9990e1b312ed637f145338689898c42604051808673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018481526020018381526020018281526020019550505050505060405180910390a1505050505050505050565b60001515611687576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260268152602001807f5472616e7366657273206f662074726f706869657320617265206e6f7420616c81526020017f6c6f7765642e000000000000000000000000000000000000000000000000000081525060400191505060405180910390fd5b505050565b600061169783611bce565b821015156116a457600080fd5b600760008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020828154811015156116f057fe5b9060005260206000200154905092915050565b600f6020528060005260406000206000915090505481565b600015156117b7576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260268152602001807f5472616e7366657273206f662074726f706869657320617265206e6f7420616c81526020017f6c6f7765642e000000000000000000000000000000000000000000000000000081525060400191505060405180910390fd5b505050565b600a6020528060005260406000206000915090505481565b600b60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6000806001600084815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff161415915050919050565b600061187661114d565b8210151561188357600080fd5b60098281548110151561189257fe5b90600052602060002001549050919050565b600b60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148061199557508173ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614801561199457508173ffffffffffffffffffffffffffffffffffffffff166010600085815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16145b5b1515611a2f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252603c8152602001807f4f6e6c79206d616e616765727320616e6420697373756572732063616e20747281526020017f616e736665722069737375616e6365206f662074726f70686965732e0000000081525060400191505060405180910390fd5b806010600085815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055507f67d5fdb405e99e9eabf7a145d87860dc9bae19d0fd312c1da804426229b563b483838342604051808581526020018473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200182815260200194505050505060405180910390a1505050565b600981815481101515611b3c57fe5b906000526020600020016000915090505481565b6000806001600084815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614151515611bc557600080fd5b80915050919050565b60008073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff1614151515611c0b57600080fd5b600360008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050919050565b60086020528060005260406000206000915090505481565b600c5481565b600080600b60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161480611d6457508373ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148015611d6357508373ffffffffffffffffffffffffffffffffffffffff166010600087815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16145b5b1515611e24576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260438152602001807f4f6e6c79206d616e616765727320616e6420697373756572732063616e20747281526020017f616e7366657220616c6c20746f6b656e7320746f2061206e657720616464726581526020017f73732e000000000000000000000000000000000000000000000000000000000081525060600191505060405180910390fd5b600091505b600760008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002080549050821015611eed57600760008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002082815481101515611ebf57fe5b90600052602060002001549050611ed68482612b1a565b611ee08382612cd6565b8180600101925050611e29565b7fe97fe5401ab5b821794177c02ee871e30394d940ff8b27351ebf6b3ca448371e848442604051808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001828152602001935050505060405180910390a15050505050565b6000808484905011151561200f576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260168152602001807f4f776e6572732063616e6e6f7420626520656d7074790000000000000000000081525060200191505060405180910390fd5b600090505b838390508110156120615761205485858584818110151561203157fe5b9050602002013573ffffffffffffffffffffffffffffffffffffffff16846121e3565b8080600101915050612014565b5050505050565b606060068054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156121005780601f106120d557610100808354040283529160200191612100565b820191906000526020600020905b8154815290600101906020018083116120e357829003601f168201915b5050505050905090565b600d5481565b600015156121ac576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260268152602001807f5472616e7366657273206f662074726f706869657320617265206e6f7420616c81526020017f6c6f7765642e000000000000000000000000000000000000000000000000000081525060400191505060405180910390fd5b5050565b60106020528060005260406000206000915054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b600b60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614801561228a575060006010600083815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614155b8061232a57508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614801561232957508273ffffffffffffffffffffffffffffffffffffffff166010600083815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16145b5b15156123c4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252602d8152602001807f4f6e6c79206d616e616765727320616e6420697373756572732063616e20697381526020017f7375652074726f70686965732e0000000000000000000000000000000000000081525060400191505060405180910390fd5b6123d082600c54612dad565b80600f6000600c5481526020019081526020016000208190555060126000828152602001908152602001600020600c5490806001815401808255809150509060018203906000526020600020016000909192909190915055507f558360ca3a70ef52d9b019da34f7041a0573db5875710b071f2d89dcd5874cf2838383600c5442604051808673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018481526020018381526020018281526020019550505050505060405180910390a1600c60008154809291906001019190505550505050565b6124fc8484846115eb565b61250884848484612e04565b151561251357600080fd5b50505050565b60116020528060005260406000206000915054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b600e8054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156125e25780601f106125b7576101008083540402835291602001916125e2565b820191906000526020600020905b8154815290600101906020018083116125c557829003601f168201915b505050505081565b6060600073ffffffffffffffffffffffffffffffffffffffff166001600084815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff161415151561265b57600080fd5b61272061266f61266a84613026565b613183565b612712600e8054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156127085780601f106126dd57610100808354040283529160200191612708565b820191906000526020600020905b8154815290600101906020018083116126eb57829003601f168201915b5050505050613183565b6131b190919063ffffffff16565b9050919050565b60076020528160005260406000208181548110151561274257fe5b90600052602060002001600091509150505481565b60126020528160005260406000208181548110151561277257fe5b90600052602060002001600091509150505481565b6000600460008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff16905092915050565b600b60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614806128a257508073ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16145b151561293c576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260358152602001807f4f6e6c79206d616e61676572732063616e2069737375652074726f706869657381526020017f206f6e20626568616c66206f66206f74686572732e000000000000000000000081525060400191505060405180910390fd5b8060106000600d54815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055507f15009d03c6c96bf1fa0facf223f0cf573e9a5b38066db5711096b3ee82e9fcd481600d5442604051808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001838152602001828152602001935050505060405180910390a1600d6000815480929190600101919050555050565b6000806000612a298585613233565b600a6000858152602001908152602001600020549250612a586001600980549050612b0190919063ffffffff16565b9150600982815481101515612a6957fe5b9060005260206000200154905080600984815481101515612a8657fe5b90600052602060002001819055506000600983815481101515612aa557fe5b90600052602060002001819055506009805480919060019003612ac89190613753565b506000600a60008681526020019081526020016000208190555082600a6000838152602001908152602001600020819055505050505050565b6000828211151515612b0f57fe5b818303905092915050565b6000806000612b2985856132a7565b60086000858152602001908152602001600020549250612b956001600760008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002080549050612b0190919063ffffffff16565b9150600760008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002082815481101515612be357fe5b9060005260206000200154905080600760008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002084815481101515612c3d57fe5b9060005260206000200181905550600760008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020805480919060019003612c9d9190613753565b50600060086000868152602001908152602001600020819055508260086000838152602001908152602001600020819055505050505050565b6000612ce283836133d6565b600760008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020805490509050600760008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020829080600181540180825580915050906001820390600052602060002001600090919290919091505550806008600084815260200190815260200160002081905550505050565b612db78282613530565b600980549050600a60008381526020019081526020016000208190555060098190806001815401808255809150509060018203906000526020600020016000909192909190915055505050565b600080612e268573ffffffffffffffffffffffffffffffffffffffff166135d6565b1515612e35576001915061301d565b8473ffffffffffffffffffffffffffffffffffffffff1663150b7a02338887876040518563ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200183815260200180602001828103825283818151815260200191508051906020019080838360005b83811015612f2a578082015181840152602081019050612f0f565b50505050905090810190601f168015612f575780820380516001836020036101000a031916815260200191505b5095505050505050602060405180830381600087803b158015612f7957600080fd5b505af1158015612f8d573d6000803e3d6000fd5b505050506040513d6020811015612fa357600080fd5b8101908080519060200190929190505050905063150b7a027c0100000000000000000000000000000000000000000000000000000000027bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916817bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19161491505b50949350505050565b606060008060006060600080871415613076576040805190810160405280600181526020017f30000000000000000000000000000000000000000000000000000000000000008152509550613179565b8694508693505b6000851415156130a3578280600101935050600a8581151561309b57fe5b04945061307d565b826040519080825280601f01601f1916602001820160405280156130d65781602001602082028038833980820191505090505b5091506001830390505b60008414151561317557600a848115156130f657fe5b066030017f01000000000000000000000000000000000000000000000000000000000000000282828060019003935081518110151561313157fe5b9060200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a905350600a8481151561316d57fe5b0493506130e0565b8195505b5050505050919050565b61318b61377f565b600060208301905060408051908101604052808451815260200182815250915050919050565b606080600083600001518560000151016040519080825280601f01601f1916602001820160405280156131f35781602001602082028038833980820191505090505b50915060208201905061320f81866020015187600001516135e9565b61322885600001518201856020015186600001516135e9565b819250505092915050565b61323d8282613634565b6132478282612b1a565b80600073ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef60405160405180910390a45050565b8173ffffffffffffffffffffffffffffffffffffffff166132c782611b50565b73ffffffffffffffffffffffffffffffffffffffff161415156132e957600080fd5b61333c6001600360008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054612b0190919063ffffffff16565b600360008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555060006001600083815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505050565b600073ffffffffffffffffffffffffffffffffffffffff166001600083815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614151561344457600080fd5b816001600083815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506134e96001600360008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205461373790919063ffffffff16565b600360008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055505050565b600073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff161415151561356c57600080fd5b6135768282612cd6565b808273ffffffffffffffffffffffffffffffffffffffff16600073ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef60405160405180910390a45050565b600080823b905060008111915050919050565b60005b60208210151561361157825184526020840193506020830192506020820391506135ec565b6001826020036101000a0390508019835116818551168181178652505050505050565b8173ffffffffffffffffffffffffffffffffffffffff1661365482611b50565b73ffffffffffffffffffffffffffffffffffffffff1614151561367657600080fd5b600073ffffffffffffffffffffffffffffffffffffffff166002600083815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff161415156137335760006002600083815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505b5050565b6000818301905082811015151561374a57fe5b80905092915050565b81548183558181111561377a578183600052602060002091820191016137799190613799565b5b505050565b604080519081016040528060008152602001600081525090565b6137bb91905b808211156137b757600081600090555060010161379f565b5090565b905600a165627a7a723058207f47d5388ed5393a7994fe9382ac1c4e3ac2e7abf322fbd0aa7dee90c1dae7bc0029"}