{"Runs": "200", "SwarmSource": "", "ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposals\",\"outputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"description\",\"type\":\"string\"},{\"name\":\"votingDeadline\",\"type\":\"uint256\"},{\"name\":\"open\",\"type\":\"bool\"},{\"name\":\"proposalPassed\",\"type\":\"bool\"},{\"name\":\"proposalHash\",\"type\":\"bytes32\"},{\"name\":\"proposalDeposit\",\"type\":\"uint256\"},{\"name\":\"newCurator\",\"type\":\"bool\"},{\"name\":\"yea\",\"type\":\"uint256\"},{\"name\":\"nay\",\"type\":\"uint256\"},{\"name\":\"creator\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minTokensToCreate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"daoCreator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"divisor\",\"outputs\":[{\"name\":\"divisor\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"extraBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposalID\",\"type\":\"uint256\"},{\"name\":\"_transactionData\",\"type\":\"bytes\"}],\"name\":\"executeProposal\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unblockMe\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalRewardToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"actualBalance\",\"outputs\":[{\"name\":\"_actualBalance\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"closingTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowedRecipients\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferWithoutReward\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_description\",\"type\":\"string\"},{\"name\":\"_transactionData\",\"type\":\"bytes\"},{\"name\":\"_debatingPeriod\",\"type\":\"uint256\"},{\"name\":\"_newCurator\",\"type\":\"bool\"}],\"name\":\"newProposal\",\"outputs\":[{\"name\":\"_proposalID\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"DAOpaidOut\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minQuorumDivisor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newContract\",\"type\":\"address\"}],\"name\":\"newContract\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_allowed\",\"type\":\"bool\"}],\"name\":\"changeAllowedRecipients\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"halveMinQuorum\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"paidOut\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposalID\",\"type\":\"uint256\"},{\"name\":\"_newCurator\",\"type\":\"address\"}],\"name\":\"splitDAO\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DAOrewardAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proposalDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOfProposals\",\"outputs\":[{\"name\":\"_numberOfProposals\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastTimeMinQuorumMet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_toMembers\",\"type\":\"bool\"}],\"name\":\"retrieveDAOReward\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"receiveEther\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFueled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenHolder\",\"type\":\"address\"}],\"name\":\"createTokenProxy\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_proposalID\",\"type\":\"uint256\"}],\"name\":\"getNewDAOAddress\",\"outputs\":[{\"name\":\"_newDAO\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposalID\",\"type\":\"uint256\"},{\"name\":\"_supportsProposal\",\"type\":\"bool\"}],\"name\":\"vote\",\"outputs\":[{\"name\":\"_voteID\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getMyReward\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFromWithoutReward\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposalDeposit\",\"type\":\"uint256\"}],\"name\":\"changeProposalDeposit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"blocked\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"curator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_proposalID\",\"type\":\"uint256\"},{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_transactionData\",\"type\":\"bytes\"}],\"name\":\"checkProposalCode\",\"outputs\":[{\"name\":\"_codeChecksOut\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"privateCreation\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_curator\",\"type\":\"address\"},{\"name\":\"_daoCreator\",\"type\":\"address\"},{\"name\":\"_proposalDeposit\",\"type\":\"uint256\"},{\"name\":\"_minTokensToCreate\",\"type\":\"uint256\"},{\"name\":\"_closingTime\",\"type\":\"uint256\"},{\"name\":\"_privateCreation\",\"type\":\"address\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"FuelingToDate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CreatedToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"proposalID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newCurator\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"description\",\"type\":\"string\"}],\"name\":\"ProposalAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"proposalID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"position\",\"type\":\"bool\"},{\"indexed\":true,\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"Voted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"proposalID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"result\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"quorum\",\"type\":\"uint256\"}],\"name\":\"ProposalTallied\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_newCurator\",\"type\":\"address\"}],\"name\":\"NewCurator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_allowed\",\"type\":\"bool\"}],\"name\":\"AllowedRecipientChanged\",\"type\":\"event\"}]", "Library": "", "CompilerVersion": "v0.3.1-2016-04-12-3ad5e82", "ConstructorArguments": "00000000000000000000000050f54ed2cafd4b7245e60557a6b56d9ac91930250000000000000000000000007d733668aefd4a1b8624410daa883b35369b663c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000574835300000000000000000000000000000000000000000000000000000000000000000", "SourceCode": "/*\r\nThis file is part of the DAO.\r\n\r\nThe DAO is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU lesser General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nThe DAO is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU lesser General Public License for more details.\r\n\r\nYou should have received a copy of the GNU lesser General Public License\r\nalong with the DAO.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n\r\n/*\r\nStandard smart contract for a Decentralized Autonomous Organization (DAO)\r\nto automate organizational governance and decision-making.\r\n*/\r\n\r\n/*\r\nThis file is part of the DAO.\r\n\r\nThe DAO is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU lesser General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nThe DAO is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU lesser General Public License for more details.\r\n\r\nYou should have received a copy of the GNU lesser General Public License\r\nalong with the DAO.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n\r\n/*\r\nBasic account, used by the DAO contract to separately manage both the rewards \r\nand the extraBalance accounts. \r\n*/\r\n\r\ncontract ManagedAccountInterface {\r\n    // The only address with permission to withdraw from this account\r\n    address public owner;\r\n    // If true, only the owner of the account can receive ether from it\r\n    bool public payOwnerOnly;\r\n    // The sum of ether (in wei) which has been sent to this contract\r\n    uint public accumulatedInput;\r\n\r\n    /// @notice Sends `_amount` of wei to _recipient\r\n    /// @param _amount The amount of wei to send to `_recipient`\r\n    /// @param _recipient The address to receive `_amount` of wei\r\n    /// @return True if the send completed\r\n    function payOut(address _recipient, uint _amount) returns (bool);\r\n\r\n    event PayOut(address indexed _recipient, uint _amount);\r\n}\r\n\r\n\r\ncontract ManagedAccount is ManagedAccountInterface{\r\n\r\n    // The constructor sets the owner of the account\r\n    function ManagedAccount(address _owner, bool _payOwnerOnly) {\r\n        owner = _owner;\r\n        payOwnerOnly = _payOwnerOnly;\r\n    }\r\n\r\n    // When the contract receives a transaction without data this is called. \r\n    // It counts the amount of ether it receives and stores it in \r\n    // accumulatedInput.\r\n    function() {\r\n        accumulatedInput += msg.value;\r\n    }\r\n\r\n    function payOut(address _recipient, uint _amount) returns (bool) {\r\n        if (msg.sender != owner || msg.value > 0 || (payOwnerOnly && _recipient != owner))\r\n            throw;\r\n        if (_recipient.call.value(_amount)()) {\r\n            PayOut(_recipient, _amount);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n\r\n/*\r\nThis file is part of the DAO.\r\n\r\nThe DAO is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU lesser General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nThe DAO is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU lesser General Public License for more details.\r\n\r\nYou should have received a copy of the GNU lesser General Public License\r\nalong with the DAO.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n\r\n/*\r\n * Token Creation contract, used by the DAO to create its tokens and initialize\r\n * its ether. Feel free to modify the divisor method to implement different\r\n * Token Creation parameters\r\n*/\r\n\r\n/*\r\nThis file is part of the DAO.\r\n\r\nThe DAO is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU lesser General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nThe DAO is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU lesser General Public License for more details.\r\n\r\nYou should have received a copy of the GNU lesser General Public License\r\nalong with the DAO.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n\r\n/*\r\nBasic, standardized Token contract with no \"premine\". Defines the functions to\r\ncheck token balances, send tokens, send tokens on behalf of a 3rd party and the\r\ncorresponding approval process. Tokens need to be created by a derived\r\ncontract (e.g. TokenCreation.sol).\r\n\r\nThank you ConsenSys, this contract originated from:\r\nhttps://github.com/ConsenSys/Tokens/blob/master/Token_Contracts/contracts/Standard_Token.sol\r\nWhich is itself based on the Ethereum standardized contract APIs:\r\nhttps://github.com/ethereum/wiki/wiki/Standardized_Contract_APIs\r\n*/\r\n\r\n/// @title Standard Token Contract.\r\n\r\ncontract TokenInterface {\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    /// Total amount of tokens\r\n    uint256 public totalSupply;\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n\r\n    /// @notice Send `_amount` tokens to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _amount The amount of tokens to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _amount) returns (bool success);\r\n\r\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\r\n    /// is approved by `_from`\r\n    /// @param _from The address of the origin of the transfer\r\n    /// @param _to The address of the recipient\r\n    /// @param _amount The amount of tokens to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _amount) returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on\r\n    /// its behalf\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _amount The amount of tokens to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _amount) returns (bool success);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens of _owner that _spender is allowed\r\n    /// to spend\r\n    function allowance(\r\n        address _owner,\r\n        address _spender\r\n    ) constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\r\n    event Approval(\r\n        address indexed _owner,\r\n        address indexed _spender,\r\n        uint256 _amount\r\n    );\r\n}\r\n\r\n\r\ncontract Token is TokenInterface {\r\n    // Protects users by preventing the execution of method calls that\r\n    // inadvertently also transferred ether\r\n    modifier noEther() {if (msg.value > 0) throw; _}\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function transfer(address _to, uint256 _amount) noEther returns (bool success) {\r\n        if (balances[msg.sender] >= _amount && _amount > 0) {\r\n            balances[msg.sender] -= _amount;\r\n            balances[_to] += _amount;\r\n            Transfer(msg.sender, _to, _amount);\r\n            return true;\r\n        } else {\r\n           return false;\r\n        }\r\n    }\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount\r\n    ) noEther returns (bool success) {\r\n\r\n        if (balances[_from] >= _amount\r\n            && allowed[_from][msg.sender] >= _amount\r\n            && _amount > 0) {\r\n\r\n            balances[_to] += _amount;\r\n            balances[_from] -= _amount;\r\n            allowed[_from][msg.sender] -= _amount;\r\n            Transfer(_from, _to, _amount);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function approve(address _spender, uint256 _amount) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _amount;\r\n        Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n}\r\n\r\ncontract TokenCreationInterface {\r\n\r\n    // End of token creation, in Unix time\r\n    uint public closingTime;\r\n    // Minimum fueling goal of the token creation, denominated in tokens to\r\n    // be created\r\n    uint public minTokensToCreate;\r\n    // True if the DAO reached its minimum fueling goal, false otherwise\r\n    bool public isFueled;\r\n    // For DAO splits - if privateCreation is 0, then it is a public token\r\n    // creation, otherwise only the address stored in privateCreation is\r\n    // allowed to create tokens\r\n    address public privateCreation;\r\n    // hold extra ether which has been sent after the DAO token\r\n    // creation rate has increased\r\n    ManagedAccount public extraBalance;\r\n    // tracks the amount of wei given from each contributor (used for refund)\r\n    mapping (address => uint256) weiGiven;\r\n\r\n    /// @dev Constructor setting the minimum fueling goal and the\r\n    /// end of the Token Creation\r\n    /// @param _minTokensToCreate Minimum fueling goal in number of\r\n    ///        Tokens to be created\r\n    /// @param _closingTime Date (in Unix time) of the end of the Token Creation\r\n    /// @param _privateCreation Zero means that the creation is public.  A\r\n    /// non-zero address represents the only address that can create Tokens\r\n    /// (the address can also create Tokens on behalf of other accounts)\r\n    // This is the constructor: it can not be overloaded so it is commented out\r\n    //  function TokenCreation(\r\n        //  uint _minTokensTocreate,\r\n        //  uint _closingTime,\r\n        //  address _privateCreation\r\n    //  );\r\n\r\n    /// @notice Create Token with `_tokenHolder` as the initial owner of the Token\r\n    /// @param _tokenHolder The address of the Tokens's recipient\r\n    /// @return Whether the token creation was successful\r\n    function createTokenProxy(address _tokenHolder) returns (bool success);\r\n\r\n    /// @notice Refund `msg.sender` in the case the Token Creation did\r\n    /// not reach its minimum fueling goal\r\n    function refund();\r\n\r\n    /// @return The divisor used to calculate the token creation rate during\r\n    /// the creation phase\r\n    function divisor() constant returns (uint divisor);\r\n\r\n    event FuelingToDate(uint value);\r\n    event CreatedToken(address indexed to, uint amount);\r\n    event Refund(address indexed to, uint value);\r\n}\r\n\r\n\r\ncontract TokenCreation is TokenCreationInterface, Token {\r\n    function TokenCreation(\r\n        uint _minTokensToCreate,\r\n        uint _closingTime,\r\n        address _privateCreation) {\r\n\r\n        closingTime = _closingTime;\r\n        minTokensToCreate = _minTokensToCreate;\r\n        privateCreation = _privateCreation;\r\n        extraBalance = new ManagedAccount(address(this), true);\r\n    }\r\n\r\n    function createTokenProxy(address _tokenHolder) returns (bool success) {\r\n        if (now < closingTime && msg.value > 0\r\n            && (privateCreation == 0 || privateCreation == msg.sender)) {\r\n\r\n            uint token = (msg.value * 20) / divisor();\r\n            extraBalance.call.value(msg.value - token)();\r\n            balances[_tokenHolder] += token;\r\n            totalSupply += token;\r\n            weiGiven[_tokenHolder] += msg.value;\r\n            CreatedToken(_tokenHolder, token);\r\n            if (totalSupply >= minTokensToCreate && !isFueled) {\r\n                isFueled = true;\r\n                FuelingToDate(totalSupply);\r\n            }\r\n            return true;\r\n        }\r\n        throw;\r\n    }\r\n\r\n    function refund() noEther {\r\n        if (now > closingTime && !isFueled) {\r\n            // Get extraBalance - will only succeed when called for the first time\r\n            if (extraBalance.balance >= extraBalance.accumulatedInput())\r\n                extraBalance.payOut(address(this), extraBalance.accumulatedInput());\r\n\r\n            // Execute refund\r\n            if (msg.sender.call.value(weiGiven[msg.sender])()) {\r\n                Refund(msg.sender, weiGiven[msg.sender]);\r\n                totalSupply -= balances[msg.sender];\r\n                balances[msg.sender] = 0;\r\n                weiGiven[msg.sender] = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    function divisor() constant returns (uint divisor) {\r\n            return 20;\r\n    }\r\n}\r\n\r\n\r\ncontract DAOInterface {\r\n\r\n    // The amount of days for which people who try to participate in the\r\n    // creation by calling the fallback function will still get their ether back\r\n    uint constant creationGracePeriod = 40 days;\r\n    // The minimum debate period that a generic proposal can have\r\n    uint constant minProposalDebatePeriod = 3 days;\r\n    // The minimum debate period that a split proposal can have\r\n    uint constant minSplitDebatePeriod = 0 days;\r\n    // Period of days inside which it's possible to execute a DAO split\r\n    uint constant splitExecutionPeriod = 1 days;\r\n    // Period of time after which the minimum Quorum is halved\r\n    uint constant quorumHalvingPeriod = 2 weeks;\r\n    // Period after which a proposal is closed\r\n    // (used in the case `executeProposal` fails because it throws)\r\n    uint constant executeProposalPeriod = 2 days;\r\n    // Denotes the maximum proposal deposit that can be given. It is given as\r\n    // a fraction of total Ether spent plus balance of the DAO\r\n    uint constant maxDepositDivisor = 100;\r\n\r\n    // Proposals to spend the DAO's ether or to choose a new Curator\r\n    Proposal[] public proposals;\r\n    // The quorum needed for each proposal is partially calculated by\r\n    // totalSupply / minQuorumDivisor\r\n    uint public minQuorumDivisor;\r\n    // The unix time of the last time quorum was reached on a proposal\r\n    uint public lastTimeMinQuorumMet;\r\n\r\n    // Address of the curator\r\n    address public curator;\r\n    // The whitelist: List of addresses the DAO is allowed to send ether to\r\n    mapping (address => bool) public allowedRecipients;\r\n\r\n    // Tracks the addresses that own Reward Tokens. Those addresses can only be\r\n    // DAOs that have split from the original DAO. Conceptually, Reward Tokens\r\n    // represent the proportion of the rewards that the DAO has the right to\r\n    // receive. These Reward Tokens are generated when the DAO spends ether.\r\n    mapping (address => uint) public rewardToken;\r\n    // Total supply of rewardToken\r\n    uint public totalRewardToken;\r\n\r\n    // The account used to manage the rewards which are to be distributed to the\r\n    // DAO Token Holders of this DAO\r\n    ManagedAccount public rewardAccount;\r\n\r\n    // The account used to manage the rewards which are to be distributed to\r\n    // any DAO that holds Reward Tokens\r\n    ManagedAccount public DAOrewardAccount;\r\n\r\n    // Amount of rewards (in wei) already paid out to a certain DAO\r\n    mapping (address => uint) public DAOpaidOut;\r\n\r\n    // Amount of rewards (in wei) already paid out to a certain address\r\n    mapping (address => uint) public paidOut;\r\n    // Map of addresses blocked during a vote (not allowed to transfer DAO\r\n    // tokens). The address points to the proposal ID.\r\n    mapping (address => uint) public blocked;\r\n\r\n    // The minimum deposit (in wei) required to submit any proposal that is not\r\n    // requesting a new Curator (no deposit is required for splits)\r\n    uint public proposalDeposit;\r\n\r\n    // the accumulated sum of all current proposal deposits\r\n    uint sumOfProposalDeposits;\r\n\r\n    // Contract that is able to create a new DAO (with the same code as\r\n    // this one), used for splits\r\n    DAO_Creator public daoCreator;\r\n\r\n    // A proposal with `newCurator == false` represents a transaction\r\n    // to be issued by this DAO\r\n    // A proposal with `newCurator == true` represents a DAO split\r\n    struct Proposal {\r\n        // The address where the `amount` will go to if the proposal is accepted\r\n        // or if `newCurator` is true, the proposed Curator of\r\n        // the new DAO).\r\n        address recipient;\r\n        // The amount to transfer to `recipient` if the proposal is accepted.\r\n        uint amount;\r\n        // A plain text description of the proposal\r\n        string description;\r\n        // A unix timestamp, denoting the end of the voting period\r\n        uint votingDeadline;\r\n        // True if the proposal's votes have yet to be counted, otherwise False\r\n        bool open;\r\n        // True if quorum has been reached, the votes have been counted, and\r\n        // the majority said yes\r\n        bool proposalPassed;\r\n        // A hash to check validity of a proposal\r\n        bytes32 proposalHash;\r\n        // Deposit in wei the creator added when submitting their proposal. It\r\n        // is taken from the msg.value of a newProposal call.\r\n        uint proposalDeposit;\r\n        // True if this proposal is to assign a new Curator\r\n        bool newCurator;\r\n        // Data needed for splitting the DAO\r\n        SplitData[] splitData;\r\n        // Number of Tokens in favor of the proposal\r\n        uint yea;\r\n        // Number of Tokens opposed to the proposal\r\n        uint nay;\r\n        // Simple mapping to check if a shareholder has voted for it\r\n        mapping (address => bool) votedYes;\r\n        // Simple mapping to check if a shareholder has voted against it\r\n        mapping (address => bool) votedNo;\r\n        // Address of the shareholder who created the proposal\r\n        address creator;\r\n    }\r\n\r\n    // Used only in the case of a newCurator proposal.\r\n    struct SplitData {\r\n        // The balance of the current DAO minus the deposit at the time of split\r\n        uint splitBalance;\r\n        // The total amount of DAO Tokens in existence at the time of split.\r\n        uint totalSupply;\r\n        // Amount of Reward Tokens owned by the DAO at the time of split.\r\n        uint rewardToken;\r\n        // The new DAO contract created at the time of split.\r\n        MICRODAO newDAO;\r\n    }\r\n\r\n    // Used to restrict access to certain functions to only DAO Token Holders\r\n    modifier onlyTokenholders {}\r\n\r\n    /// @dev Constructor setting the Curator and the address\r\n    /// for the contract able to create another DAO as well as the parameters\r\n    /// for the DAO Token Creation\r\n    /// @param _curator The Curator\r\n    /// @param _daoCreator The contract able to (re)create this DAO\r\n    /// @param _proposalDeposit The deposit to be paid for a regular proposal\r\n    /// @param _minTokensToCreate Minimum required wei-equivalent tokens\r\n    ///        to be created for a successful DAO Token Creation\r\n    /// @param _closingTime Date (in Unix time) of the end of the DAO Token Creation\r\n    /// @param _privateCreation If zero the DAO Token Creation is open to public, a\r\n    /// non-zero address means that the DAO Token Creation is only for the address\r\n    // This is the constructor: it can not be overloaded so it is commented out\r\n    //  function DAO(\r\n        //  address _curator,\r\n        //  DAO_Creator _daoCreator,\r\n        //  uint _proposalDeposit,\r\n        //  uint _minTokensToCreate,\r\n        //  uint _closingTime,\r\n        //  addresses _privateCreation\r\n    //  );\r\n\r\n    /// @notice Create Token with `msg.sender` as the beneficiary\r\n    /// @return Whether the token creation was successful\r\n    function () returns (bool success);\r\n\r\n\r\n    /// @dev This function is used to send ether back\r\n    /// to the DAO, it can also be used to receive payments that should not be\r\n    /// counted as rewards (donations, grants, etc.)\r\n    /// @return Whether the DAO received the ether successfully\r\n    function receiveEther() returns(bool);\r\n\r\n    /// @notice `msg.sender` creates a proposal to send `_amount` Wei to\r\n    /// `_recipient` with the transaction data `_transactionData`. If\r\n    /// `_newCurator` is true, then this is a proposal that splits the\r\n    /// DAO and sets `_recipient` as the new DAO's Curator.\r\n    /// @param _recipient Address of the recipient of the proposed transaction\r\n    /// @param _amount Amount of wei to be sent with the proposed transaction\r\n    /// @param _description String describing the proposal\r\n    /// @param _transactionData Data of the proposed transaction\r\n    /// @param _debatingPeriod Time used for debating a proposal, at least 2\r\n    /// weeks for a regular proposal, 10 days for new Curator proposal\r\n    /// @param _newCurator Bool defining whether this proposal is about\r\n    /// a new Curator or not\r\n    /// @return The proposal ID. Needed for voting on the proposal\r\n    function newProposal(\r\n        address _recipient,\r\n        uint _amount,\r\n        string _description,\r\n        bytes _transactionData,\r\n        uint _debatingPeriod,\r\n        bool _newCurator\r\n    ) onlyTokenholders returns (uint _proposalID);\r\n\r\n    /// @notice Check that the proposal with the ID `_proposalID` matches the\r\n    /// transaction which sends `_amount` with data `_transactionData`\r\n    /// to `_recipient`\r\n    /// @param _proposalID The proposal ID\r\n    /// @param _recipient The recipient of the proposed transaction\r\n    /// @param _amount The amount of wei to be sent in the proposed transaction\r\n    /// @param _transactionData The data of the proposed transaction\r\n    /// @return Whether the proposal ID matches the transaction data or not\r\n    function checkProposalCode(\r\n        uint _proposalID,\r\n        address _recipient,\r\n        uint _amount,\r\n        bytes _transactionData\r\n    ) constant returns (bool _codeChecksOut);\r\n\r\n    /// @notice Vote on proposal `_proposalID` with `_supportsProposal`\r\n    /// @param _proposalID The proposal ID\r\n    /// @param _supportsProposal Yes/No - support of the proposal\r\n    /// @return The vote ID.\r\n    function vote(\r\n        uint _proposalID,\r\n        bool _supportsProposal\r\n    ) onlyTokenholders returns (uint _voteID);\r\n\r\n    /// @notice Checks whether proposal `_proposalID` with transaction data\r\n    /// `_transactionData` has been voted for or rejected, and executes the\r\n    /// transaction in the case it has been voted for.\r\n    /// @param _proposalID The proposal ID\r\n    /// @param _transactionData The data of the proposed transaction\r\n    /// @return Whether the proposed transaction has been executed or not\r\n    function executeProposal(\r\n        uint _proposalID,\r\n        bytes _transactionData\r\n    ) returns (bool _success);\r\n\r\n    /// @notice ATTENTION! I confirm to move my remaining ether to a new DAO\r\n    /// with `_newCurator` as the new Curator, as has been\r\n    /// proposed in proposal `_proposalID`. This will burn my tokens. This can\r\n    /// not be undone and will split the DAO into two DAO's, with two\r\n    /// different underlying tokens.\r\n    /// @param _proposalID The proposal ID\r\n    /// @param _newCurator The new Curator of the new DAO\r\n    /// @dev This function, when called for the first time for this proposal,\r\n    /// will create a new DAO and send the sender's portion of the remaining\r\n    /// ether and Reward Tokens to the new DAO. It will also burn the DAO Tokens\r\n    /// of the sender.\r\n    function splitDAO(\r\n        uint _proposalID,\r\n        address _newCurator\r\n    ) returns (bool _success);\r\n\r\n    /// @dev can only be called by the DAO itself through a proposal\r\n    /// updates the contract of the DAO by sending all ether and rewardTokens\r\n    /// to the new DAO. The new DAO needs to be approved by the Curator\r\n    /// @param _newContract the address of the new contract\r\n    function newContract(address _newContract);\r\n\r\n\r\n    /// @notice Add a new possible recipient `_recipient` to the whitelist so\r\n    /// that the DAO can send transactions to them (using proposals)\r\n    /// @param _recipient New recipient address\r\n    /// @dev Can only be called by the current Curator\r\n    /// @return Whether successful or not\r\n    function changeAllowedRecipients(address _recipient, bool _allowed) external returns (bool _success);\r\n\r\n\r\n    /// @notice Change the minimum deposit required to submit a proposal\r\n    /// @param _proposalDeposit The new proposal deposit\r\n    /// @dev Can only be called by this DAO (through proposals with the\r\n    /// recipient being this DAO itself)\r\n    function changeProposalDeposit(uint _proposalDeposit) external;\r\n\r\n    /// @notice Move rewards from the DAORewards managed account\r\n    /// @param _toMembers If true rewards are moved to the actual reward account\r\n    ///                   for the DAO. If not then it's moved to the DAO itself\r\n    /// @return Whether the call was successful\r\n    function retrieveDAOReward(bool _toMembers) external returns (bool _success);\r\n\r\n    /// @notice Get my portion of the reward that was sent to `rewardAccount`\r\n    /// @return Whether the call was successful\r\n    function getMyReward() returns(bool _success);\r\n\r\n    /// @notice Withdraw `_account`'s portion of the reward from `rewardAccount`\r\n    /// to `_account`'s balance\r\n    /// @return Whether the call was successful\r\n    function withdrawRewardFor(address _account) internal returns (bool _success);\r\n\r\n    /// @notice Send `_amount` tokens to `_to` from `msg.sender`. Prior to this\r\n    /// getMyReward() is called.\r\n    /// @param _to The address of the recipient\r\n    /// @param _amount The amount of tokens to be transfered\r\n    /// @return Whether the transfer was successful or not\r\n    function transferWithoutReward(address _to, uint256 _amount) returns (bool success);\r\n\r\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\r\n    /// is approved by `_from`. Prior to this getMyReward() is called.\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _amount The amount of tokens to be transfered\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFromWithoutReward(\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount\r\n    ) returns (bool success);\r\n\r\n    /// @notice Doubles the 'minQuorumDivisor' in the case quorum has not been\r\n    /// achieved in 52 weeks\r\n    /// @return Whether the change was successful or not\r\n    function halveMinQuorum() returns (bool _success);\r\n\r\n    /// @return total number of proposals ever created\r\n    function numberOfProposals() constant returns (uint _numberOfProposals);\r\n\r\n    /// @param _proposalID Id of the new curator proposal\r\n    /// @return Address of the new DAO\r\n    function getNewDAOAddress(uint _proposalID) constant returns (address _newDAO);\r\n\r\n    /// @param _account The address of the account which is checked.\r\n    /// @return Whether the account is blocked (not allowed to transfer tokens) or not.\r\n    function isBlocked(address _account) internal returns (bool);\r\n\r\n    /// @notice If the caller is blocked by a proposal whose voting deadline\r\n    /// has exprired then unblock him.\r\n    /// @return Whether the account is blocked (not allowed to transfer tokens) or not.\r\n    function unblockMe() returns (bool);\r\n\r\n    event ProposalAdded(\r\n        uint indexed proposalID,\r\n        address recipient,\r\n        uint amount,\r\n        bool newCurator,\r\n        string description\r\n    );\r\n    event Voted(uint indexed proposalID, bool position, address indexed voter);\r\n    event ProposalTallied(uint indexed proposalID, bool result, uint quorum);\r\n    event NewCurator(address indexed _newCurator);\r\n    event AllowedRecipientChanged(address indexed _recipient, bool _allowed);\r\n}\r\n\r\n// The DAO contract itself\r\ncontract MICRODAO is DAOInterface, Token, TokenCreation {\r\n\r\n    // Modifier that allows only shareholders to vote and create new proposals\r\n    modifier onlyTokenholders {\r\n        if (balanceOf(msg.sender) == 0) throw;\r\n            _\r\n    }\r\n\r\n    function MICRODAO(\r\n        address _curator,\r\n        DAO_Creator _daoCreator,\r\n        uint _proposalDeposit,\r\n        uint _minTokensToCreate,\r\n        uint _closingTime,\r\n        address _privateCreation\r\n    ) TokenCreation(_minTokensToCreate, _closingTime, _privateCreation) {\r\n\r\n        curator = _curator;\r\n        daoCreator = _daoCreator;\r\n        proposalDeposit = _proposalDeposit;\r\n        rewardAccount = new ManagedAccount(address(this), false);\r\n        DAOrewardAccount = new ManagedAccount(address(this), false);\r\n        if (address(rewardAccount) == 0)\r\n            throw;\r\n        if (address(DAOrewardAccount) == 0)\r\n            throw;\r\n        lastTimeMinQuorumMet = now;\r\n        minQuorumDivisor = 5; // sets the minimal quorum to 20%\r\n        proposals.length = 1; // avoids a proposal with ID 0 because it is used\r\n\r\n        allowedRecipients[address(this)] = true;\r\n        allowedRecipients[curator] = true;\r\n    }\r\n\r\n    function () returns (bool success) {\r\n        if (now < closingTime + creationGracePeriod && msg.sender != address(extraBalance))\r\n            return createTokenProxy(msg.sender);\r\n        else\r\n            return receiveEther();\r\n    }\r\n\r\n\r\n    function receiveEther() returns (bool) {\r\n        return true;\r\n    }\r\n\r\n\r\n    function newProposal(\r\n        address _recipient,\r\n        uint _amount,\r\n        string _description,\r\n        bytes _transactionData,\r\n        uint _debatingPeriod,\r\n        bool _newCurator\r\n    ) onlyTokenholders returns (uint _proposalID) {\r\n\r\n        // Sanity check\r\n        if (_newCurator && (\r\n            _amount != 0\r\n            || _transactionData.length != 0\r\n            || _recipient == curator\r\n            || msg.value > 0)) {\r\n            throw;\r\n        } else if (\r\n            !_newCurator\r\n            && (!isRecipientAllowed(_recipient) || (_debatingPeriod <  minProposalDebatePeriod))\r\n        ) {\r\n            throw;\r\n        }\r\n\r\n        if (_debatingPeriod > 8 weeks)\r\n            throw;\r\n\r\n        if (!isFueled\r\n            || now < closingTime\r\n            || (msg.value < proposalDeposit && !_newCurator)) {\r\n\r\n            throw;\r\n        }\r\n\r\n        if (now + _debatingPeriod < now) // prevents overflow\r\n            throw;\r\n\r\n        // to prevent a 51% attacker to convert the ether into deposit\r\n        if (msg.sender == address(this))\r\n            throw;\r\n\r\n        // to prevent curator from halving quorum before first proposal\r\n        if (proposals.length == 1) // initial length is 1 (see constructor)\r\n            lastTimeMinQuorumMet = now;\r\n\r\n        _proposalID = proposals.length++;\r\n        Proposal p = proposals[_proposalID];\r\n        p.recipient = _recipient;\r\n        p.amount = _amount;\r\n        p.description = _description;\r\n        p.proposalHash = sha3(_recipient, _amount, _transactionData);\r\n        p.votingDeadline = now + _debatingPeriod;\r\n        p.open = true;\r\n        //p.proposalPassed = False; // that's default\r\n        p.newCurator = _newCurator;\r\n        if (_newCurator)\r\n            p.splitData.length++;\r\n        p.creator = msg.sender;\r\n        p.proposalDeposit = msg.value;\r\n\r\n        sumOfProposalDeposits += msg.value;\r\n\r\n        ProposalAdded(\r\n            _proposalID,\r\n            _recipient,\r\n            _amount,\r\n            _newCurator,\r\n            _description\r\n        );\r\n    }\r\n\r\n\r\n    function checkProposalCode(\r\n        uint _proposalID,\r\n        address _recipient,\r\n        uint _amount,\r\n        bytes _transactionData\r\n    ) noEther constant returns (bool _codeChecksOut) {\r\n        Proposal p = proposals[_proposalID];\r\n        return p.proposalHash == sha3(_recipient, _amount, _transactionData);\r\n    }\r\n\r\n\r\n    function vote(\r\n        uint _proposalID,\r\n        bool _supportsProposal\r\n    ) onlyTokenholders noEther returns (uint _voteID) {\r\n\r\n        Proposal p = proposals[_proposalID];\r\n        if (p.votedYes[msg.sender]\r\n            || p.votedNo[msg.sender]\r\n            || now >= p.votingDeadline) {\r\n\r\n            throw;\r\n        }\r\n\r\n        if (_supportsProposal) {\r\n            p.yea += balances[msg.sender];\r\n            p.votedYes[msg.sender] = true;\r\n        } else {\r\n            p.nay += balances[msg.sender];\r\n            p.votedNo[msg.sender] = true;\r\n        }\r\n\r\n        if (blocked[msg.sender] == 0) {\r\n            blocked[msg.sender] = _proposalID;\r\n        } else if (p.votingDeadline > proposals[blocked[msg.sender]].votingDeadline) {\r\n            // this proposal's voting deadline is further into the future than\r\n            // the proposal that blocks the sender so make it the blocker\r\n            blocked[msg.sender] = _proposalID;\r\n        }\r\n\r\n        Voted(_proposalID, _supportsProposal, msg.sender);\r\n    }\r\n\r\n\r\n    function executeProposal(\r\n        uint _proposalID,\r\n        bytes _transactionData\r\n    ) noEther returns (bool _success) {\r\n\r\n        Proposal p = proposals[_proposalID];\r\n\r\n        uint waitPeriod = p.newCurator\r\n            ? splitExecutionPeriod\r\n            : executeProposalPeriod;\r\n        // If we are over deadline and waiting period, assert proposal is closed\r\n        if (p.open && now > p.votingDeadline + waitPeriod) {\r\n            closeProposal(_proposalID);\r\n            return;\r\n        }\r\n\r\n        // Check if the proposal can be executed\r\n        if (now < p.votingDeadline  // has the voting deadline arrived?\r\n            // Have the votes been counted?\r\n            || !p.open\r\n            // Does the transaction code match the proposal?\r\n            || p.proposalHash != sha3(p.recipient, p.amount, _transactionData)) {\r\n\r\n            throw;\r\n        }\r\n\r\n        // If the curator removed the recipient from the whitelist, close the proposal\r\n        // in order to free the deposit and allow unblocking of voters\r\n        if (!isRecipientAllowed(p.recipient)) {\r\n            closeProposal(_proposalID);\r\n            p.creator.send(p.proposalDeposit);\r\n            return;\r\n        }\r\n\r\n        bool proposalCheck = true;\r\n\r\n        if (p.amount > actualBalance())\r\n            proposalCheck = false;\r\n\r\n        uint quorum = p.yea + p.nay;\r\n\r\n        // require 53% for calling newContract()\r\n        if (_transactionData.length >= 4 && _transactionData[0] == 0x68\r\n            && _transactionData[1] == 0x37 && _transactionData[2] == 0xff\r\n            && _transactionData[3] == 0x1e\r\n            && quorum < minQuorum(actualBalance() + rewardToken[address(this)])) {\r\n\r\n                proposalCheck = false;\r\n        }\r\n\r\n        if (quorum >= minQuorum(p.amount)) {\r\n            if (!p.creator.send(p.proposalDeposit))\r\n                throw;\r\n\r\n            lastTimeMinQuorumMet = now;\r\n            // set the minQuorum to 20% again, in the case it has been reached\r\n            if (quorum > totalSupply / 5)\r\n                minQuorumDivisor = 5;\r\n        }\r\n\r\n        // Execute result\r\n        if (quorum >= minQuorum(p.amount) && p.yea > p.nay && proposalCheck) {\r\n            if (!p.recipient.call.value(p.amount)(_transactionData))\r\n                throw;\r\n\r\n            p.proposalPassed = true;\r\n            _success = true;\r\n\r\n            // only create reward tokens when ether is not sent to the DAO itself and\r\n            // related addresses. Proxy addresses should be forbidden by the curator.\r\n            if (p.recipient != address(this) && p.recipient != address(rewardAccount)\r\n                && p.recipient != address(DAOrewardAccount)\r\n                && p.recipient != address(extraBalance)\r\n                && p.recipient != address(curator)) {\r\n\r\n                rewardToken[address(this)] += p.amount;\r\n                totalRewardToken += p.amount;\r\n            }\r\n        }\r\n\r\n        closeProposal(_proposalID);\r\n\r\n        // Initiate event\r\n        ProposalTallied(_proposalID, _success, quorum);\r\n    }\r\n\r\n\r\n    function closeProposal(uint _proposalID) internal {\r\n        Proposal p = proposals[_proposalID];\r\n        if (p.open)\r\n            sumOfProposalDeposits -= p.proposalDeposit;\r\n        p.open = false;\r\n    }\r\n\r\n    function splitDAO(\r\n        uint _proposalID,\r\n        address _newCurator\r\n    ) noEther onlyTokenholders returns (bool _success) {\r\n\r\n        Proposal p = proposals[_proposalID];\r\n\r\n        // Sanity check\r\n\r\n        if (now < p.votingDeadline  // has the voting deadline arrived?\r\n            //The request for a split expires XX days after the voting deadline\r\n            || now > p.votingDeadline + splitExecutionPeriod\r\n            // Does the new Curator address match?\r\n            || p.recipient != _newCurator\r\n            // Is it a new curator proposal?\r\n            || !p.newCurator\r\n            // Have you voted for this split?\r\n            || !p.votedYes[msg.sender]\r\n            // Did you already vote on another proposal?\r\n            || (blocked[msg.sender] != _proposalID && blocked[msg.sender] != 0) )  {\r\n\r\n            throw;\r\n        }\r\n\r\n        // If the new DAO doesn't exist yet, create the new DAO and store the\r\n        // current split data\r\n        if (address(p.splitData[0].newDAO) == 0) {\r\n            p.splitData[0].newDAO = createNewDAO(_newCurator);\r\n            // Call depth limit reached, etc.\r\n            if (address(p.splitData[0].newDAO) == 0)\r\n                throw;\r\n            // should never happen\r\n            if (this.balance < sumOfProposalDeposits)\r\n                throw;\r\n            p.splitData[0].splitBalance = actualBalance();\r\n            p.splitData[0].rewardToken = rewardToken[address(this)];\r\n            p.splitData[0].totalSupply = totalSupply;\r\n            p.proposalPassed = true;\r\n        }\r\n\r\n        // Move ether and assign new Tokens\r\n        uint fundsToBeMoved =\r\n            (balances[msg.sender] * p.splitData[0].splitBalance) /\r\n            p.splitData[0].totalSupply;\r\n        if (p.splitData[0].newDAO.createTokenProxy.value(fundsToBeMoved)(msg.sender) == false)\r\n            throw;\r\n\r\n\r\n        // Assign reward rights to new DAO\r\n        uint rewardTokenToBeMoved =\r\n            (balances[msg.sender] * p.splitData[0].rewardToken) /\r\n            p.splitData[0].totalSupply;\r\n\r\n        uint paidOutToBeMoved = DAOpaidOut[address(this)] * rewardTokenToBeMoved /\r\n            rewardToken[address(this)];\r\n\r\n        rewardToken[address(p.splitData[0].newDAO)] += rewardTokenToBeMoved;\r\n        if (rewardToken[address(this)] < rewardTokenToBeMoved)\r\n            throw;\r\n        rewardToken[address(this)] -= rewardTokenToBeMoved;\r\n\r\n        DAOpaidOut[address(p.splitData[0].newDAO)] += paidOutToBeMoved;\r\n        if (DAOpaidOut[address(this)] < paidOutToBeMoved)\r\n            throw;\r\n        DAOpaidOut[address(this)] -= paidOutToBeMoved;\r\n\r\n        // Burn DAO Tokens\r\n        Transfer(msg.sender, 0, balances[msg.sender]);\r\n        withdrawRewardFor(msg.sender); // be nice, and get his rewards\r\n        totalSupply -= balances[msg.sender];\r\n        balances[msg.sender] = 0;\r\n        paidOut[msg.sender] = 0;\r\n        return true;\r\n    }\r\n\r\n    function newContract(address _newContract){\r\n        if (msg.sender != address(this) || !allowedRecipients[_newContract]) return;\r\n        // move all ether\r\n        if (!_newContract.call.value(address(this).balance)()) {\r\n            throw;\r\n        }\r\n\r\n        //move all reward tokens\r\n        rewardToken[_newContract] += rewardToken[address(this)];\r\n        rewardToken[address(this)] = 0;\r\n        DAOpaidOut[_newContract] += DAOpaidOut[address(this)];\r\n        DAOpaidOut[address(this)] = 0;\r\n    }\r\n\r\n\r\n    function retrieveDAOReward(bool _toMembers) external noEther returns (bool _success) {\r\n        MICRODAO dao = MICRODAO(msg.sender);\r\n\r\n        if ((rewardToken[msg.sender] * DAOrewardAccount.accumulatedInput()) /\r\n            totalRewardToken < DAOpaidOut[msg.sender])\r\n            throw;\r\n\r\n        uint reward =\r\n            (rewardToken[msg.sender] * DAOrewardAccount.accumulatedInput()) /\r\n            totalRewardToken - DAOpaidOut[msg.sender];\r\n\r\n        reward = DAOrewardAccount.balance < reward ? DAOrewardAccount.balance : reward;\r\n\r\n        if(_toMembers) {\r\n            if (!DAOrewardAccount.payOut(dao.rewardAccount(), reward))\r\n                throw;\r\n            }\r\n        else {\r\n            if (!DAOrewardAccount.payOut(dao, reward))\r\n                throw;\r\n        }\r\n        DAOpaidOut[msg.sender] += reward;\r\n        return true;\r\n    }\r\n\r\n    function getMyReward() noEther returns (bool _success) {\r\n        return withdrawRewardFor(msg.sender);\r\n    }\r\n\r\n\r\n    function withdrawRewardFor(address _account) noEther internal returns (bool _success) {\r\n        if ((balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply < paidOut[_account])\r\n            throw;\r\n\r\n        uint reward =\r\n            (balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply - paidOut[_account];\r\n\r\n        reward = rewardAccount.balance < reward ? rewardAccount.balance : reward;\r\n\r\n        if (!rewardAccount.payOut(_account, reward))\r\n            throw;\r\n        paidOut[_account] += reward;\r\n        return true;\r\n    }\r\n\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        if (isFueled\r\n            && now > closingTime\r\n            && !isBlocked(msg.sender)\r\n            && transferPaidOut(msg.sender, _to, _value)\r\n            && super.transfer(_to, _value)) {\r\n\r\n            return true;\r\n        } else {\r\n            throw;\r\n        }\r\n    }\r\n\r\n\r\n    function transferWithoutReward(address _to, uint256 _value) returns (bool success) {\r\n        if (!getMyReward())\r\n            throw;\r\n        return transfer(_to, _value);\r\n    }\r\n\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        if (isFueled\r\n            && now > closingTime\r\n            && !isBlocked(_from)\r\n            && transferPaidOut(_from, _to, _value)\r\n            && super.transferFrom(_from, _to, _value)) {\r\n\r\n            return true;\r\n        } else {\r\n            throw;\r\n        }\r\n    }\r\n\r\n\r\n    function transferFromWithoutReward(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) returns (bool success) {\r\n\r\n        if (!withdrawRewardFor(_from))\r\n            throw;\r\n        return transferFrom(_from, _to, _value);\r\n    }\r\n\r\n\r\n    function transferPaidOut(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) internal returns (bool success) {\r\n\r\n        uint transferPaidOut = paidOut[_from] * _value / balanceOf(_from);\r\n        if (transferPaidOut > paidOut[_from])\r\n            throw;\r\n        paidOut[_from] -= transferPaidOut;\r\n        paidOut[_to] += transferPaidOut;\r\n        return true;\r\n    }\r\n\r\n\r\n    function changeProposalDeposit(uint _proposalDeposit) noEther external {\r\n        if (msg.sender != address(this) || _proposalDeposit > (actualBalance() + rewardToken[address(this)])\r\n            / maxDepositDivisor) {\r\n\r\n            throw;\r\n        }\r\n        proposalDeposit = _proposalDeposit;\r\n    }\r\n\r\n\r\n    function changeAllowedRecipients(address _recipient, bool _allowed) noEther external returns (bool _success) {\r\n        if (msg.sender != curator)\r\n            throw;\r\n        allowedRecipients[_recipient] = _allowed;\r\n        AllowedRecipientChanged(_recipient, _allowed);\r\n        return true;\r\n    }\r\n\r\n\r\n    function isRecipientAllowed(address _recipient) internal returns (bool _isAllowed) {\r\n        if (allowedRecipients[_recipient]\r\n            || (_recipient == address(extraBalance)\r\n                // only allowed when at least the amount held in the\r\n                // extraBalance account has been spent from the DAO\r\n                && totalRewardToken > extraBalance.accumulatedInput()))\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n\r\n    function actualBalance() constant returns (uint _actualBalance) {\r\n        return this.balance - sumOfProposalDeposits;\r\n    }\r\n\r\n\r\n    function minQuorum(uint _value) internal constant returns (uint _minQuorum) {\r\n        // minimum of 20% and maximum of 53.33%\r\n        return totalSupply / minQuorumDivisor +\r\n            (_value * totalSupply) / (3 * (actualBalance() + rewardToken[address(this)]));\r\n    }\r\n\r\n\r\n    function halveMinQuorum() returns (bool _success) {\r\n        // this can only be called after `quorumHalvingPeriod` has passed or at anytime after\r\n        // fueling by the curator with a delay of at least `minProposalDebatePeriod`\r\n        // between the calls\r\n        if ((lastTimeMinQuorumMet < (now - quorumHalvingPeriod) || msg.sender == curator)\r\n            && lastTimeMinQuorumMet < (now - minProposalDebatePeriod)\r\n            && now >= closingTime\r\n            && proposals.length > 1) {\r\n            lastTimeMinQuorumMet = now;\r\n            minQuorumDivisor *= 2;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function createNewDAO(address _newCurator) internal returns (MICRODAO _newDAO) {\r\n        NewCurator(_newCurator);\r\n        return daoCreator.createDAO(_newCurator, 0, 0, now + splitExecutionPeriod);\r\n    }\r\n\r\n    function numberOfProposals() constant returns (uint _numberOfProposals) {\r\n        // Don't count index 0. It's used by isBlocked() and exists from start\r\n        return proposals.length - 1;\r\n    }\r\n\r\n    function getNewDAOAddress(uint _proposalID) constant returns (address _newDAO) {\r\n        return proposals[_proposalID].splitData[0].newDAO;\r\n    }\r\n\r\n    function isBlocked(address _account) internal returns (bool) {\r\n        if (blocked[_account] == 0)\r\n            return false;\r\n        Proposal p = proposals[blocked[_account]];\r\n        if (now > p.votingDeadline) {\r\n            blocked[_account] = 0;\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function unblockMe() returns (bool) {\r\n        return isBlocked(msg.sender);\r\n    }\r\n}\r\n\r\ncontract DAO_Creator {\r\n    function createDAO(\r\n        address _curator,\r\n        uint _proposalDeposit,\r\n        uint _minTokensToCreate,\r\n        uint _closingTime\r\n    ) returns (MICRODAO _newDAO) {\r\n\r\n        return new MICRODAO(\r\n            _curator,\r\n            DAO_Creator(this),\r\n            _proposalDeposit,\r\n            _minTokensToCreate,\r\n            _closingTime,\r\n            msg.sender\r\n        );\r\n    }\r\n}", "OptimizationUsed": "1", "ContractName": "MICRODAO", "ByteCode": "0x6060604052361561020e5760e060020a6000350463013cf08b8114610247578063095ea7b3146102d05780630c3b7b96146103455780630e7082031461034e578063149acf9a1461036057806318160ddd146103725780631f2dc5ef1461037b57806321b5b8dd14610386578063237e94921461039857806323b872dd146103f95780632632bf201461042c578063341458081461045d57806339d1f908146104665780634b6753bc1461047e5780634df6d6cc146104875780634e10c3ee146104a2578063590e1ae3146104b5578063612e45a3146104c6578063643f7cdd14610565578063674ed0661461057d5780636837ff1e1461058657806370a08231146105d0578063749f9889146105f657806378524b2e1461060f57806381f03fcb1461068657806382661dc41461069e57806382bf6464146106bf5780638b15a605146106d15780638d7af473146106da57806396d7f3f5146106e9578063a1da2fb9146106f2578063a3912ec81461070c578063a9059cbb14610717578063b7bc2c8414610747578063baac530014610753578063be7c29c1146107b9578063c9d27afe1461081f578063cc9ae3f614610835578063cdef91d014610849578063dbde198814610861578063dd62ed3e14610886578063e33734fd146108ba578063e5962195146108ce578063e66f53b7146108e6578063eceb2945146108f8578063f8c80d2614610957575b61096e600f546000906234bc000142108015610239575060125433600160a060020a03908116911614155b15610980576109883361075a565b61098e6004356000805482908110156100025750808052600e8202600080516020612a6283398151915201905060038101546004820154600683015460018401548454600786015460058701546009880154600a890154600d8a0154600160a060020a039586169b509599600201989760ff81811698610100909204811697949691951693168c565b61096e60043560243533600160a060020a03908116600081815260156020908152604080832094871680845294825280832086905580518681529051929493927f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925929181900390910190a35060015b92915050565b61096e60105481565b610a85600754600160a060020a031681565b610a85600e54600160a060020a031681565b61096e60165481565b61096e5b601461098b565b610a85601254600160a060020a031681565b60408051602060248035600481810135601f810185900485028601850190965285855261096e958135959194604494929390920191819084018382808284375094965050505050505060006000600060006000600034111561167857610002565b61096e6004356024356044355b60115460009060ff16801561041c5750600f5442115b80156124f457506124f284610436565b61096e6000610988335b600160a060020a0381166000908152600b602052604081205481908114156129f757610ba1565b61096e60065481565b61096e5b600d5430600160a060020a0316310361098b565b61096e600f5481565b61096e60043560046020526000908152604090205460ff1681565b61096e60043560243560006124d6610839565b610aa26000341115610bac57610002565b604080516020604435600481810135601f810184900484028501840190955284845261096e948135946024803595939460649492939101918190840183828082843750506040805160209735808a0135601f81018a90048a0283018a01909352828252969897608497919650602491909101945090925082915084018382808284375094965050933593505060a43591505060006000610de9336105d7565b61096e60043560096020526000908152604090205481565b61096e60015481565b610aa260043530600160a060020a031633600160a060020a03161415806105c65750600160a060020a03811660009081526004602052604090205460ff16155b1561219a57612197565b61096e6004355b600160a060020a0381166000908152601460205260409020545b919050565b61096e600435602435600060003411156125a457610002565b61096e6000621275004203600260005054108061063b5750600354600160a060020a0390811633909116145b801561064f57506002546203f47f19420190105b801561065d5750600f544210155b801561066c5750600054600190115b1561261f575042600290815560018054909102815561098b565b61096e600435600a6020526000908152604090205481565b61096e600435602435600060006000600060006000341115611b7157610002565b610a85600854600160a060020a031681565b61096e600c5481565b61096e6000546000190161098b565b61096e60025481565b61096e60043560006000600060003411156121cb57610002565b61096e5b600161098b565b61096e6004356024355b60115460009060ff1680156107375750600f5442115b8015612492575061249033610436565b61096e60115460ff1681565b61096e6004355b60006000600f60005054421080156107725750600034115b80156107ac57506011546101009004600160a060020a0316600014806107ac57506011546101009004600160a060020a0390811633909116145b15610ba757610aa461037f565b610a85600435600060006000508281548110156100025750508080527f290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e56b600e83020180548290811015610002575081526020902060030154600160a060020a03166105f1565b61096e6004356024356000600061141d336105d7565b61096e5b6000600034111561248757610002565b61096e60043560056020526000908152604090205481565b61096e600435602435604435600061253a845b6000600060003411156127b757610002565b61096e600435602435600160a060020a0382811660009081526015602090815260408083209385168352929052205461033f565b610aa2600435600034111561255057610002565b61096e600435600b6020526000908152604090205481565b610a85600354600160a060020a031681565b604080516020606435600481810135601f810184900484028501840190955284845261096e9481359460248035956044359560849492019190819084018382808284375094965050505050505060006000600034111561138e57610002565b610a856011546101009004600160a060020a031681565b60408051918252519081900360200190f35b610988610710565b90505b90565b604051808d600160a060020a031681526020018c8152602001806020018b81526020018a815260200189815260200188815260200187815260200186815260200185815260200184815260200183600160a060020a0316815260200182810382528c818154600181600116156101000203166002900481526020019150805460018160011615610100020316600290048015610a6b5780601f10610a4057610100808354040283529160200191610a6b565b820191906000526020600020905b815481529060010190602001808311610a4e57829003601f168201915b50509d505050505050505050505050505060405180910390f35b60408051600160a060020a03929092168252519081900360200190f35b005b604051601254601434908102939093049350600160a060020a03169183900390600081818185876185025a03f150505050600160a060020a038316600081815260146020908152604080832080548601905560168054860190556013825291829020805434019055815184815291517fdbccb92686efceafb9bb7e0394df7f58f71b954061b81afb57109bf247d3d75a9281900390910190a260105460165410801590610b54575060115460ff16155b15610b9c576011805460ff1916600117905560165460408051918252517ff381a3e2428fdda36615919e8d9c35878d9eb0cf85ac6edf575088e80e4c147e9181900360200190a15b600191505b50919050565b610002565b600f5442118015610bc0575060115460ff16155b15610de757601260009054906101000a9004600160a060020a0316600160a060020a031663d2cc718f6040518160e060020a0281526004018090506020604051808303816000876161da5a03f11561000257505060405151601254600160a060020a031631109050610ccd576040805160125460e060020a63d2cc718f0282529151600160a060020a039290921691630221038a913091849163d2cc718f91600482810192602092919082900301816000876161da5a03f11561000257505060408051805160e160020a63011081c5028252600160a060020a039490941660048201526024810193909352516044838101936020935082900301816000876161da5a03f115610002575050505b33600160a060020a0316600081815260136020526040808220549051909181818185876185025a03f19250505015610de75733600160a060020a03167fbb28353e4598c3b9199101a66e0989549b659a59a54d2c27fbb183f1932c8e6d6013600050600033600160a060020a03168152602001908152602001600020600050546040518082815260200191505060405180910390a26014600050600033600160a060020a0316815260200190815260200160002060005054601660008282825054039250508190555060006014600050600033600160a060020a031681526020019081526020016000206000508190555060006013600050600033600160a060020a03168152602001908152602001600020600050819055505b565b60001415610df657610002565b828015610e335750866000141580610e1057508451600014155b80610e285750600354600160a060020a038981169116145b80610e335750600034115b15610e3d57610002565b82158015610e5d5750610e4f88610e77565b1580610e5d57506203f48084105b15610f1957610002565b83546118b590600160a060020a03165b600160a060020a03811660009081526004602052604081205460ff1680610f0c5750601254600160a060020a03908116908316148015610f0c5750601260009054906101000a9004600160a060020a0316600160a060020a031663d2cc718f6040518160e060020a0281526004018090506020604051808303816000876161da5a03f115610002575050604051516006541190505b156129cd575060016105f1565b6249d400841115610f2957610002565b60115460ff161580610f3c5750600f5442105b80610f515750600c5434108015610f51575082155b15610f5b57610002565b428442011015610f6a57610002565b30600160a060020a031633600160a060020a03161415610f8957610002565b60005460011415610f9957426002555b6000805460018101808355909190828015829011610fd057600e0281600e028360005260206000209182019101610fd09190611095565b505060008054929450918491508110156100025750808052600e8302600080516020612a628339815191520190508054600160a060020a031916891781556001818101899055875160028084018054600082815260209081902096975091959481161561010002600019011691909104601f908101829004840193918b019083901061118d57805160ff19168380011785555b506111bd929150611175565b5050600060098201819055600a820155600d81018054600160a060020a03191690556001015b80821115611189578054600160a060020a03191681556000600182810182905560028084018054848255909281161561010002600019011604601f81901061115b57505b506000600383018190556004808401805461ffff19169055600584018290556006840182905560078401805460ff19169055600884018054838255908352602090922061106f929091028101905b8082111561118957600080825560018201818155600283019190915560039091018054600160a060020a0319169055611127565b601f0160209004906000526020600020908101906110d991905b808211156111895760008155600101611175565b5090565b82800160010185558215611063579182015b8281111561106357825182600050559160200191906001019061119f565b50508787866040518084600160a060020a0316606060020a0281526014018381526020018280519060200190808383829060006004602084601f0104600f02600301f150905001935050505060405180910390208160050160005081905550834201816003016000508190555060018160040160006101000a81548160ff02191690830217905550828160070160006101000a81548160ff0219169083021790555082156112a3576008810180546001810180835590919082801582901161129e5760040281600402836000526020600020918201910161129e9190611127565b505050505b600d8082018054600160a060020a031916331790553460068301819055815401905560408051600160a060020a038a16815260208181018a9052918101859052608060608201818152895191830191909152885185937f5790de2c279e58269b93b12828f56fd5f2bc8ad15e61ce08572585c81a38756f938d938d938a938e93929160a084019185810191908190849082908590600090600490601f850104600f02600301f150905090810190601f1680156113735780820380516001836020036101000a031916815260200191505b509550505050505060405180910390a2509695505050505050565b6000805487908110156100025750808052600e8702600080516020612a6283398151915201905090508484846040518084600160a060020a0316606060020a0281526014018381526020018280519060200190808383829060006004602084601f0104600f02600301f15090500193505050506040518091039020816005016000505414915050949350505050565b6000141561142a57610002565b600034111561143857610002565b6000805485908110156100025750600160a060020a0333168152600e85027f290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e56e8101602052604090912054600080516020612a6283398151915291909101915060ff16806114b15750600c810160205260406000205460ff165b806114c0575060038101544210155b156114ca57610002565b82156115105733600160a060020a03166000908152601460209081526040808320546009850180549091019055600b84019091529020805460ff1916600117905561154c565b33600160a060020a0316600090815260146020908152604080832054600a850180549091019055600c84019091529020805460ff191660011790555b33600160a060020a03166000908152600b602052604081205414156115785760406000208490556115ec565b33600160a060020a03166000908152600b60205260408120548154811015610002579080527f290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e566600e9091020154600382015411156115ec5733600160a060020a03166000908152600b602052604090208490555b60408051848152905133600160a060020a03169186917f86abfce99b7dd908bec0169288797f85049ec73cbe046ed9de818fab3a497ae09181900360200190a35092915050565b6040805186815260208101839052815189927fdfc78bdca8e3e0b18c16c5c99323c6cb9eb5e00afde190b4e7273f5158702b07928290030190a25b5050505092915050565b6000805488908110156100025750808052600e8802600080516020612a62833981519152019050600781015490945060ff166116b7576202a3006116bc565b620151805b600485015490935060ff1680156116d857506003840154830142115b156116e65761178887611860565b60038401544210806116fd5750600484015460ff16155b8061177e57508360000160009054906101000a9004600160a060020a03168460010160005054876040518084600160a060020a0316606060020a0281526014018381526020018280519060200190808383829060006004602084601f0104600f02600301f15090500193505050506040518091039020846005016000505414155b15610e6757610002565b61166e565b60048401805461ff001916610100179055835460019550600160a060020a0390811630909116148015906117d157508354600754600160a060020a03908116911614155b80156117ed57506008548454600160a060020a03908116911614155b801561180957508354601254600160a060020a03908116911614155b801561182557506003548454600160a060020a03908116911614155b1561185b5760018401805430600160a060020a031660009081526005602052604090208054919091019055546006805490910190555b611633875b6000600060005082815481101561000257908052600e02600080516020612a62833981519152018150600481015490915060ff16156118a757600d80546006830154900390555b600401805460ff1916905550565b15156118c4576118d087611860565b6001915061190161046a565b604051600d8501546006860154600160a060020a0391909116916000919082818181858883f193505050505061166e565b6001850154111561191157600091505b50600a8301546009840154865191019060049010801590611956575085600081518110156100025790602001015160f860020a900460f860020a02606860f860020a02145b8015611986575085600181518110156100025790602001015160f860020a900460f860020a02603760f860020a02145b80156119b6575085600281518110156100025790602001015160f860020a900460f860020a0260ff60f860020a02145b80156119e6575085600381518110156100025790602001015160f860020a900460f860020a02601e60f860020a02145b8015611a15575030600160a060020a0316600090815260056020526040902054611a1290611a2d61046a565b81105b15611a1f57600091505b6001840154611a5090611a2f565b015b30600160a060020a03166000908152600560205260408120546129d561046a565b8110611aa457604051600d8501546006860154600160a060020a0391909116916000919082818181858883f193505050501515611a8c57610002565b4260025560165460059004811115611aa45760056001555b6001840154611ab290611a2f565b8110158015611ac85750600a8401546009850154115b8015611ad15750815b1561185b578360000160009054906101000a9004600160a060020a0316600160a060020a0316846001016000505487604051808280519060200190808383829060006004602084601f0104600f02600301f150905090810190601f168015611b4d5780820380516001836020036101000a031916815260200191505b5091505060006040518083038185876185025a03f192505050151561178d57610002565b611b7a336105d7565b60001415611b8757610002565b60008054889081101561000257508052600e87027f290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e566810154600080516020612a62833981519152919091019450421080611be957506003840154620151800142115b80611c0157508354600160a060020a03878116911614155b80611c115750600784015460ff16155b80611c37575033600160a060020a03166000908152600b8501602052604090205460ff16155b80611c6b575033600160a060020a03166000908152600b60205260409020548714801590611c6b5750604060009081205414155b15611c7557610002565b600884018054600090811015610002579081526020812060030154600160a060020a03161415611de157611ecb86604051600090600160a060020a038316907f9046fefd66f538ab35263248a44217dcb70e2eb2cd136629e141b8b8f9f03b60908390a260408051600e547fe2faf044000000000000000000000000000000000000000000000000000000008252600160a060020a03858116600484015260248301859052604483018590526201518042016064840152925192169163e2faf04491608480820192602092909190829003018187876161da5a03f1156100025750506040515191506105f19050565b6008850180546000908110156100025781815260208082209390935530600160a060020a031681526005909252604082205481549092908110156100025790815260208120905060020155601654600885018054600090811015610002579081526020812090506001015560048401805461ff0019166101001790555b6008840180546000908110156100025781548282526020822060010154929190811015610002579081526020812090505433600160a060020a031660009081526014602052604081205460088801805493909102939093049550908110156100025790815260208120905060030154604080517fbaac530000000000000000000000000000000000000000000000000000000000815233600160a060020a0390811660048301529151929091169163baac53009186916024808301926020929190829003018185886185025a03f11561000257505060405151600014159150611f47905057610002565b60088501805460009081101561000257818152602081206003018054600160a060020a03191690931790925580549091908110156100025790815260208120905060030154600160a060020a031660001415611f2657610002565b600d5430600160a060020a0316311015611f3f57610002565b611d6461046a565b6008840180546000908110156100025781548282526020822060010154929190811015610002579081526020812090506002015433600160a060020a0390811660009081526014602090815260408083205430909416835260058083528184205460099093529083205460088b018054969095029690960497509487020494508593929091908290811015610002575260208120815060030154600160a060020a0390811682526020828101939093526040918201600090812080549095019094553016835260059091529020548290101561202257610002565b30600160a060020a031660009081526005602052604081208054849003905560088501805483926009929091829081101561000257508152602080822060030154600160a060020a0390811683529290526040808220805490940190935530909116815220548190101561209557610002565b30600160a060020a0390811660009081526009602090815260408083208054869003905533909316808352601482528383205484519081529351929390927fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef929181900390910190a361210733610874565b5033600160a060020a03166000908152601460209081526040808320805460168054919091039055839055600a9091528120556001945061166e565b30600160a060020a0390811660008181526005602090815260408083208054958716808552828520805490970190965584845283905560099091528082208054948352908220805490940190935590815290555b50565b604051600160a060020a0382811691309091163190600081818185876185025a03f192505050151561214357610002565b33600160a060020a03818116600090815260096020908152604080832054815160065460085460e060020a63d2cc718f028352935197995091969195929092169363d2cc718f936004848101949193929183900301908290876161da5a03f11561000257505050604051805190602001506005600050600033600160a060020a03168152602001908152602001600020600050540204101561226c57610002565b600160a060020a03338116600090815260096020908152604080832054815160065460085460e060020a63d2cc718f02835293519296909593169363d2cc718f93600483810194929383900301908290876161da5a03f11561000257505050604051805190602001506005600050600033600160a060020a0316815260200190815260200160002060005054020403905080600860009054906101000a9004600160a060020a0316600160a060020a031631106123295780612337565b600854600160a060020a0316315b905083156123f757600860009054906101000a9004600160a060020a0316600160a060020a0316630221038a83600160a060020a0316630e7082036040518160e060020a0281526004018090506020604051808303816000876161da5a03f11561000257505060408051805160e160020a63011081c5028252600160a060020a031660048201526024810186905290516044828101935060209282900301816000876161da5a03f115610002575050604051511515905061245f57610002565b6040805160085460e160020a63011081c5028252600160a060020a038581166004840152602483018590529251921691630221038a9160448082019260209290919082900301816000876161da5a03f115610002575050604051511515905061245f57610002565b600160a060020a03331660009081526009602052604090208054909101905550600192915050565b61098833610874565b155b80156124ad57506124ad3384845b60006000612966856105d7565b80156124c957506124c983836000600034111561262757610002565b15610ba75750600161033f565b15156124e157610002565b6124eb8383610721565b905061033f565b155b801561250657506125068484846124a0565b80156125235750612523848484600060003411156126cc57610002565b15610ba757506001612533565b90505b9392505050565b151561254557610002565b612530848484610406565b30600160a060020a031633600160a060020a0316141580612595575030600160a060020a031660009081526005602052604090205460649061259061046a565b010481115b1561259f57610002565b600c55565b600354600160a060020a0390811633909116146125c057610002565b600160a060020a038316600081815260046020908152604091829020805460ff191686179055815185815291517f73ad2a153c8b67991df9459024950b318a609782cee8c7eeda47b905f9baa91f9281900390910190a250600161033f565b50600061098b565b33600160a060020a03166000908152601460205260409020548290108015906126505750600082115b156126c457600160a060020a03338116600081815260146020908152604080832080548890039055938716808352918490208054870190558351868152935191937fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef929081900390910190a350600161033f565b50600061033f565b600160a060020a0384166000908152601460205260409020548290108015906127155750601560209081526040600081812033600160a060020a03168252909252902054829010155b80156127215750600082115b156127af57600160a060020a03838116600081815260146020908152604080832080548801905588851680845281842080548990039055601583528184203390961684529482529182902080548790039055815186815291519293927fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef9281900390910190a3506001612533565b506000612533565b600160a060020a038381166000908152600a6020908152604080832054601654600754835160e060020a63d2cc718f02815293519296919591169363d2cc718f9360048181019492939183900301908290876161da5a03f115610002575050604051519050612825866105d7565b0204101561283257610002565b600160a060020a038381166000908152600a6020908152604080832054601654600754835160e060020a63d2cc718f02815293519296919591169363d2cc718f9360048181019492939183900301908290876161da5a03f1156100025750506040515190506128a0866105d7565b600754910291909104919091039150600160a060020a0316318190106128c657806128d4565b600754600160a060020a0316315b6007546040805160e160020a63011081c5028152600160a060020a038781166004830152602482018590529151939450911691630221038a9160448082019260209290919082900301816000876161da5a03f115610002575050604051511515905061293f57610002565b600160a060020a0383166000908152600a6020526040902080548201905560019150610ba1565b600160a060020a0386166000908152600a602052604090205480850291909104915081111561299457610002565b600160a060020a038581166000908152600a60205260408082208054859003905591861681522080548201905560019150509392505050565b5060006105f1565b01600302601660005054830204600160005054601660005054040190506105f1565b600160a060020a0383166000908152600b6020526040812054815481101561000257818052600e02600080516020612a628339815191520190506003810154909150421115610b9c57600160a060020a0383166000908152600b602052604081208190559150610ba156290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563"}