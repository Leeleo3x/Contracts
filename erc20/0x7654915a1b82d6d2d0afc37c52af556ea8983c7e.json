{"Runs": "200", "SwarmSource": "bzzr://c2472a96c6479f1e7c1d773671b9e912525eb9cd0de22f2737804e0ca947c803", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setTransferAgent\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintingFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setReleaseAgent\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"mintAgents\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setMintAgent\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"upgrade\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"setTokenInformation\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgradeAgent\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"releaseTokenTransfer\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgradeMaster\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUpgradeState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"transferAgents\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"released\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"canUpgrade\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeSub\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalUpgraded\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeMul\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"releaseAgent\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"agent\",\"type\":\"address\"}],\"name\":\"setUpgradeAgent\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeAdd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"master\",\"type\":\"address\"}],\"name\":\"setUpgradeMaster\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_initialSupply\",\"type\":\"uint256\"},{\"name\":\"_decimals\",\"type\":\"uint8\"},{\"name\":\"_mintable\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newName\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"newSymbol\",\"type\":\"string\"}],\"name\":\"UpdatedTokenInformation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Upgrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"agent\",\"type\":\"address\"}],\"name\":\"UpgradeAgentSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"MintingAgentChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Minted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]", "Library": "", "CompilerVersion": "v0.4.11+commit.68ef5810", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000004466565640000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034946540000000000000000000000000000000000000000000000000000000000", "SourceCode": "pragma solidity ^0.4.11;\r\n// Thanks to OpenZeppeline & TokenMarket for the awesome Libraries.\r\ncontract SafeMathLib {\r\n  function safeMul(uint a, uint b) returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n  address public newOwner;\r\n  event OwnershipTransferred(address indexed _from, address indexed _to);\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n  modifier onlyOwner {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n  function transferOwnership(address _newOwner) onlyOwner {\r\n    newOwner = _newOwner;\r\n  }\r\n\r\n  function acceptOwnership() {\r\n    require(msg.sender == newOwner);\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n  \r\n}\r\n\r\ncontract ERC20Basic {\r\n  uint public totalSupply;\r\n  function balanceOf(address who) constant returns (uint);\r\n  function transfer(address _to, uint _value) returns (bool success);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) constant returns (uint);\r\n  function transferFrom(address _from, address _to, uint _value) returns (bool success);\r\n  function approve(address _spender, uint _value) returns (bool success);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract FractionalERC20 is ERC20 {\r\n  uint8 public decimals;\r\n}\r\n\r\ncontract StandardToken is ERC20, SafeMathLib {\r\n  /* Token supply got increased and a new owner received these tokens */\r\n  event Minted(address receiver, uint amount);\r\n\r\n  /* Actual balances of token holders */\r\n  mapping(address => uint) balances;\r\n\r\n  /* approve() allowances */\r\n  mapping (address => mapping (address => uint)) allowed;\r\n\r\n  function transfer(address _to, uint _value) returns (bool success) {\r\n    if (balances[msg.sender] >= _value \r\n        && _value > 0 \r\n        && balances[_to] + _value > balances[_to]\r\n        ) {\r\n      balances[msg.sender] = safeSub(balances[msg.sender],_value);\r\n      balances[_to] = safeAdd(balances[_to],_value);\r\n      Transfer(msg.sender, _to, _value);\r\n      return true;\r\n    }\r\n    else{\r\n      return false;\r\n    }\r\n    \r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint _value) returns (bool success) {\r\n    uint _allowance = allowed[_from][msg.sender];\r\n\r\n    if (balances[_from] >= _value   // From a/c has balance\r\n        && _allowance >= _value    // Transfer approved\r\n        && _value > 0              // Non-zero transfer\r\n        && balances[_to] + _value > balances[_to]  // Overflow check\r\n        ){\r\n    balances[_to] = safeAdd(balances[_to],_value);\r\n    balances[_from] = safeSub(balances[_from],_value);\r\n    allowed[_from][msg.sender] = safeSub(_allowance,_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n        }\r\n    else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  function balanceOf(address _owner) constant returns (uint balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function approve(address _spender, uint _value) returns (bool success) {\r\n\r\n    // To change the approve amount you first have to reduce the addresses`\r\n    //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n    //  already 0 to mitigate the race condition described here:\r\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    require(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));\r\n    //if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\r\n\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * Upgrade agent interface inspired by Lunyr.\r\n *\r\n * Upgrade agent transfers tokens to a new contract.\r\n * Upgrade agent itself can be the token contract, or just a middle man contract doing the heavy lifting.\r\n */\r\ncontract UpgradeAgent {\r\n  uint public originalSupply;\r\n  /** Interface marker */\r\n  function isUpgradeAgent() public constant returns (bool) {\r\n    return true;\r\n  }\r\n  function upgradeFrom(address _from, uint256 _value) public;\r\n}\r\n\r\n/**\r\n * A token upgrade mechanism where users can opt-in amount of tokens to the next smart contract revision.\r\n *\r\n * First envisioned by Golem and Lunyr projects.\r\n */\r\ncontract UpgradeableToken is StandardToken {\r\n\r\n  /** Contract / person who can set the upgrade path. This can be the same as team multisig wallet, as what it is with its default value. */\r\n  address public upgradeMaster;\r\n\r\n  /** The next contract where the tokens will be migrated. */\r\n  UpgradeAgent public upgradeAgent;\r\n\r\n  /** How many tokens we have upgraded by now. */\r\n  uint256 public totalUpgraded;\r\n\r\n  /**\r\n   * Upgrade states.\r\n   *\r\n   * - NotAllowed: The child contract has not reached a condition where the upgrade can bgun\r\n   * - WaitingForAgent: Token allows upgrade, but we don't have a new agent yet\r\n   * - ReadyToUpgrade: The agent is set, but not a single token has been upgraded yet\r\n   * - Upgrading: Upgrade agent is set and the balance holders can upgrade their tokens\r\n   *\r\n   */\r\n  enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}\r\n\r\n  /**\r\n   * Somebody has upgraded some of his tokens.\r\n   */\r\n  event Upgrade(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n  /**\r\n   * New upgrade agent available.\r\n   */\r\n  event UpgradeAgentSet(address agent);\r\n\r\n  /**\r\n   * Do not allow construction without upgrade master set.\r\n   */\r\n  function UpgradeableToken(address _upgradeMaster) {\r\n    upgradeMaster = _upgradeMaster;\r\n  }\r\n\r\n  /**\r\n   * Allow the token holder to upgrade some of their tokens to a new contract.\r\n   */\r\n  function upgrade(uint256 value) public {\r\n    UpgradeState state = getUpgradeState();\r\n    require((state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading));\r\n    // if(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) {\r\n    //   // Called in a bad state\r\n    //   throw;\r\n    // }\r\n\r\n    // Validate input value.\r\n    if (value == 0) throw;\r\n\r\n    balances[msg.sender] = safeSub(balances[msg.sender],value);\r\n\r\n    // Take tokens out from circulation\r\n    totalSupply = safeSub(totalSupply,value);\r\n    totalUpgraded = safeAdd(totalUpgraded,value);\r\n\r\n    // Upgrade agent reissues the tokens\r\n    upgradeAgent.upgradeFrom(msg.sender, value);\r\n    Upgrade(msg.sender, upgradeAgent, value);\r\n  }\r\n\r\n  /**\r\n   * Set an upgrade agent that handles\r\n   */\r\n  function setUpgradeAgent(address agent) external {\r\n    require(canUpgrade());\r\n    // if(!canUpgrade()) {\r\n    //   // The token is not yet in a state that we could think upgrading\r\n    //   throw;\r\n    // }\r\n\r\n    require(agent != 0x0);\r\n    //if (agent == 0x0) throw;\r\n    // Only a master can designate the next agent\r\n    require(msg.sender == upgradeMaster);\r\n    //if (msg.sender != upgradeMaster) throw;\r\n    // Upgrade has already begun for an agent\r\n    require(getUpgradeState() != UpgradeState.Upgrading);\r\n    //if (getUpgradeState() == UpgradeState.Upgrading) throw;\r\n\r\n    upgradeAgent = UpgradeAgent(agent);\r\n\r\n    // Bad interface\r\n    require(upgradeAgent.isUpgradeAgent());\r\n    //if(!upgradeAgent.isUpgradeAgent()) throw;\r\n    // Make sure that token supplies match in source and target\r\n    require(upgradeAgent.originalSupply() == totalSupply);\r\n    //if (upgradeAgent.originalSupply() != totalSupply) throw;\r\n\r\n    UpgradeAgentSet(upgradeAgent);\r\n  }\r\n\r\n  /**\r\n   * Get the state of the token upgrade.\r\n   */\r\n  function getUpgradeState() public constant returns(UpgradeState) {\r\n    if(!canUpgrade()) return UpgradeState.NotAllowed;\r\n    else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent;\r\n    else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;\r\n    else return UpgradeState.Upgrading;\r\n  }\r\n\r\n  /**\r\n   * Change the upgrade master.\r\n   *\r\n   * This allows us to set a new owner for the upgrade mechanism.\r\n   */\r\n  function setUpgradeMaster(address master) public {\r\n    require(master != 0x0);\r\n    //if (master == 0x0) throw;\r\n    require(msg.sender == upgradeMaster);\r\n    //if (msg.sender != upgradeMaster) throw;\r\n    upgradeMaster = master;\r\n  }\r\n\r\n  /**\r\n   * Child contract can enable to provide the condition when the upgrade can begun.\r\n   */\r\n  function canUpgrade() public constant returns(bool) {\r\n     return true;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * Define interface for releasing the token transfer after a successful crowdsale.\r\n */\r\ncontract ReleasableToken is ERC20, Ownable {\r\n\r\n  /* The finalizer contract that allows unlift the transfer limits on this token */\r\n  address public releaseAgent;\r\n\r\n  /** A crowdsale contract can release us to the wild if ICO success. If false we are are in transfer lock up period.*/\r\n  bool public released = false;\r\n\r\n  /** Map of agents that are allowed to transfer tokens regardless of the lock down period. These are crowdsale contracts and possible the team multisig itself. */\r\n  mapping (address => bool) public transferAgents;\r\n\r\n  /**\r\n   * Limit token transfer until the crowdsale is over.\r\n   *\r\n   */\r\n  modifier canTransfer(address _sender) {\r\n\r\n    if(!released) {\r\n        require(transferAgents[_sender]);\r\n        // if(!transferAgents[_sender]) {\r\n        //     throw;\r\n        // }\r\n    }\r\n\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * Set the contract that can call release and make the token transferable.\r\n   *\r\n   * Design choice. Allow reset the release agent to fix fat finger mistakes.\r\n   */\r\n  function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\r\n\r\n    // We don't do interface check here as we might want to a normal wallet address to act as a release agent\r\n    releaseAgent = addr;\r\n  }\r\n\r\n  /**\r\n   * Owner can allow a particular address (a crowdsale contract) to transfer tokens despite the lock up period.\r\n   */\r\n  function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\r\n    transferAgents[addr] = state;\r\n  }\r\n\r\n  /**\r\n   * One way function to release the tokens to the wild.\r\n   *\r\n   * Can be called only from the release agent that is the final ICO contract. It is only called if the crowdsale has been success (first milestone reached).\r\n   */\r\n  function releaseTokenTransfer() public onlyReleaseAgent {\r\n    released = true;\r\n  }\r\n\r\n  /** The function can be called only before or after the tokens have been releasesd */\r\n  modifier inReleaseState(bool releaseState) {\r\n    require(releaseState == released);\r\n    // if(releaseState != released) {\r\n    //     throw;\r\n    // }\r\n    _;\r\n  }\r\n\r\n  /** The function can be called only by a whitelisted release agent. */\r\n  modifier onlyReleaseAgent() {\r\n    require(msg.sender == releaseAgent);\r\n    // if(msg.sender != releaseAgent) {\r\n    //     throw;\r\n    // }\r\n    _;\r\n  }\r\n\r\n  function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {\r\n    // Call StandardToken.transfer()\r\n   return super.transfer(_to, _value);\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {\r\n    // Call StandardToken.transferForm()\r\n    return super.transferFrom(_from, _to, _value);\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * A token that can increase its supply by another contract.\r\n *\r\n * This allows uncapped crowdsale by dynamically increasing the supply when money pours in.\r\n * Only mint agents, contracts whitelisted by owner, can mint new tokens.\r\n *\r\n */\r\ncontract MintableToken is StandardToken, Ownable {\r\n\r\n  bool public mintingFinished = false;\r\n\r\n  /** List of agents that are allowed to create new tokens */\r\n  mapping (address => bool) public mintAgents;\r\n\r\n  event MintingAgentChanged(address addr, bool state  );\r\n\r\n  /**\r\n   * Create new tokens and allocate them to an address..\r\n   *\r\n   * Only callably by a crowdsale contract (mint agent).\r\n   */\r\n  function mint(address receiver, uint amount) onlyMintAgent canMint public {\r\n    totalSupply = safeAdd(totalSupply, amount);\r\n    balances[receiver] = safeAdd(balances[receiver], amount);\r\n\r\n    // This will make the mint transaction apper in EtherScan.io\r\n    // We can remove this after there is a standardized minting event\r\n    Transfer(0, receiver, amount);\r\n  }\r\n\r\n  /**\r\n   * Owner can allow a crowdsale contract to mint new tokens.\r\n   */\r\n  function setMintAgent(address addr, bool state) onlyOwner canMint public {\r\n    mintAgents[addr] = state;\r\n    MintingAgentChanged(addr, state);\r\n  }\r\n\r\n  modifier onlyMintAgent() {\r\n    // Only crowdsale contracts are allowed to mint new tokens\r\n    require(mintAgents[msg.sender]);\r\n    // if(!mintAgents[msg.sender]) {\r\n    //     throw;\r\n    // }\r\n    _;\r\n  }\r\n\r\n  /** Make sure we are not done yet. */\r\n  modifier canMint() {\r\n    require(!mintingFinished);\r\n    //if(mintingFinished) throw;\r\n    _;\r\n  }\r\n}\r\n\r\n/**\r\n * A crowdsaled token.\r\n *\r\n * An ERC-20 token designed specifically for crowdsales with investor protection and further development path.\r\n *\r\n * - The token transfer() is disabled until the crowdsale is over\r\n * - The token contract gives an opt-in upgrade path to a new contract\r\n * - The same token can be part of several crowdsales through approve() mechanism\r\n * - The token can be capped (supply set in the constructor) or uncapped (crowdsale contract can mint new tokens)\r\n *\r\n */\r\ncontract CrowdsaleToken is ReleasableToken, MintableToken, UpgradeableToken {\r\n\r\n  event UpdatedTokenInformation(string newName, string newSymbol);\r\n\r\n  string public name;\r\n\r\n  string public symbol;\r\n\r\n  uint8 public decimals;\r\n\r\n  /**\r\n   * Construct the token.\r\n   *\r\n   * This token must be created through a team multisig wallet, so that it is owned by that wallet.\r\n   *\r\n   * @param _name Token name\r\n   * @param _symbol Token symbol - should be all caps\r\n   * @param _initialSupply How many tokens we start with\r\n   * @param _decimals Number of decimal places\r\n   * @param _mintable Are new tokens created over the crowdsale or do we distribute only the initial supply? Note that when the token becomes transferable the minting always ends.\r\n   */\r\n  function CrowdsaleToken(string _name, string _symbol, uint _initialSupply, uint8 _decimals, bool _mintable)\r\n    UpgradeableToken(msg.sender) {\r\n\r\n    // Create any address, can be transferred\r\n    // to team multisig via changeOwner(),\r\n    // also remember to call setUpgradeMaster()\r\n    owner = msg.sender;\r\n\r\n    name = _name;\r\n    symbol = _symbol;\r\n\r\n    totalSupply = _initialSupply;\r\n\r\n    decimals = _decimals;\r\n\r\n    // Create initially all balance on the team multisig\r\n    balances[owner] = totalSupply;\r\n\r\n    if(totalSupply > 0) {\r\n      Minted(owner, totalSupply);\r\n    }\r\n\r\n    // No more new supply allowed after the token creation\r\n    if(!_mintable) {\r\n      mintingFinished = true;\r\n      require(totalSupply != 0);\r\n      // if(totalSupply == 0) {\r\n      //   throw; // Cannot create a token without supply and no minting\r\n      // }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * When token is released to be transferable, enforce no new tokens can be created.\r\n   */\r\n  function releaseTokenTransfer() public onlyReleaseAgent {\r\n    mintingFinished = true;\r\n    super.releaseTokenTransfer();\r\n  }\r\n\r\n  /**\r\n   * Allow upgrade agent functionality kick in only if the crowdsale was success.\r\n   */\r\n  function canUpgrade() public constant returns(bool) {\r\n    return released && super.canUpgrade();\r\n  }\r\n\r\n  /**\r\n   * Owner can update token information here\r\n   */\r\n  function setTokenInformation(string _name, string _symbol) onlyOwner {\r\n    name = _name;\r\n    symbol = _symbol;\r\n    UpdatedTokenInformation(name, symbol);\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * Finalize agent defines what happens at the end of succeseful crowdsale.\r\n *\r\n * - Allocate tokens for founders, bounties and community\r\n * - Make tokens transferable\r\n * - etc.\r\n */\r\ncontract FinalizeAgent {\r\n\r\n  function isFinalizeAgent() public constant returns(bool) {\r\n    return true;\r\n  }\r\n\r\n  /** Return true if we can run finalizeCrowdsale() properly.\r\n   *\r\n   * This is a safety check function that doesn't allow crowdsale to begin\r\n   * unless the finalizer has been set up properly.\r\n   */\r\n  function isSane() public constant returns (bool);\r\n\r\n  /** Called once by crowdsale finalize() if the sale was success. */\r\n  function finalizeCrowdsale();\r\n\r\n}\r\n\r\n/**\r\n * Interface for defining crowdsale pricing.\r\n */\r\ncontract PricingStrategy {\r\n\r\n  /** Interface declaration. */\r\n  function isPricingStrategy() public constant returns (bool) {\r\n    return true;\r\n  }\r\n\r\n  /** Self check if all references are correctly set.\r\n   *\r\n   * Checks that pricing strategy matches crowdsale parameters.\r\n   */\r\n  function isSane(address crowdsale) public constant returns (bool) {\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * When somebody tries to buy tokens for X eth, calculate how many tokens they get.\r\n   *\r\n   *\r\n   * @param value - What is the value of the transaction send in as wei\r\n   * @param tokensSold - how much tokens have been sold this far\r\n   * @param weiRaised - how much money has been raised this far\r\n   * @param msgSender - who is the investor of this transaction\r\n   * @param decimals - how many decimal units the token has\r\n   * @return Amount of tokens the investor receives\r\n   */\r\n  function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);\r\n}\r\n\r\n/*\r\n * Haltable\r\n *\r\n * Abstract contract that allows children to implement an\r\n * emergency stop mechanism. Differs from Pausable by causing a throw when in halt mode.\r\n *\r\n *\r\n * Originally envisioned in FirstBlood ICO contract.\r\n */\r\ncontract Haltable is Ownable {\r\n  bool public halted;\r\n\r\n  modifier stopInEmergency {\r\n    require(!halted);\r\n    //if (halted) throw;\r\n    _;\r\n  }\r\n\r\n  modifier onlyInEmergency {\r\n    require(halted);\r\n    //if (!halted) throw;\r\n    _;\r\n  }\r\n\r\n  // called by the owner on emergency, triggers stopped state\r\n  function halt() external onlyOwner {\r\n    halted = true;\r\n  }\r\n\r\n  // called by the owner on end of emergency, returns to normal state\r\n  function unhalt() external onlyOwner onlyInEmergency {\r\n    halted = false;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * Abstract base contract for token sales.\r\n *\r\n * Handle\r\n * - start and end dates\r\n * - accepting investments\r\n * - minimum funding goal and refund\r\n * - various statistics during the crowdfund\r\n * - different pricing strategies\r\n * - different investment policies (require server side customer id, allow only whitelisted addresses)\r\n *\r\n */\r\ncontract Crowdsale is Haltable, SafeMathLib {\r\n\r\n  /* Max investment count when we are still allowed to change the multisig address */\r\n  uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\r\n\r\n  /* The token we are selling */\r\n  FractionalERC20 public token;\r\n\r\n  /* How we are going to price our offering */\r\n  PricingStrategy public pricingStrategy;\r\n\r\n  /* Post-success callback */\r\n  FinalizeAgent public finalizeAgent;\r\n\r\n  /* tokens will be transfered from this address */\r\n  address public multisigWallet;\r\n\r\n  /* if the funding goal is not reached, investors may withdraw their funds */\r\n  uint public minimumFundingGoal;\r\n\r\n  /* the UNIX timestamp start date of the crowdsale */\r\n  uint public startsAt;\r\n\r\n  /* the UNIX timestamp end date of the crowdsale */\r\n  uint public endsAt;\r\n\r\n  /* the number of tokens already sold through this contract*/\r\n  uint public tokensSold = 0;\r\n\r\n  /* How many wei of funding we have raised */\r\n  uint public weiRaised = 0;\r\n\r\n  /* How many distinct addresses have invested */\r\n  uint public investorCount = 0;\r\n\r\n  /* How much wei we have returned back to the contract after a failed crowdfund. */\r\n  uint public loadedRefund = 0;\r\n\r\n  /* How much wei we have given back to investors.*/\r\n  uint public weiRefunded = 0;\r\n\r\n  /* Has this crowdsale been finalized */\r\n  bool public finalized;\r\n\r\n  /* Do we need to have unique contributor id for each customer */\r\n  bool public requireCustomerId;\r\n\r\n  /**\r\n    * Do we verify that contributor has been cleared on the server side (accredited investors only).\r\n    * This method was first used in FirstBlood crowdsale to ensure all contributors have accepted terms on sale (on the web).\r\n    */\r\n  bool public requiredSignedAddress;\r\n\r\n  /* Server side address that signed allowed contributors (Ethereum addresses) that can participate the crowdsale */\r\n  address public signerAddress;\r\n\r\n  /** How much ETH each address has invested to this crowdsale */\r\n  mapping (address => uint256) public investedAmountOf;\r\n\r\n  /** How much tokens this crowdsale has credited for each investor address */\r\n  mapping (address => uint256) public tokenAmountOf;\r\n\r\n  /** Addresses that are allowed to invest even before ICO offical opens. For testing, for ICO partners, etc. */\r\n  mapping (address => bool) public earlyParticipantWhitelist;\r\n\r\n  /** This is for manul testing for the interaction from owner wallet. You can set it to any value and inspect this in blockchain explorer to see that crowdsale interaction works. */\r\n  uint public ownerTestValue;\r\n\r\n  /** State machine\r\n   *\r\n   * - Preparing: All contract initialization calls and variables have not been set yet\r\n   * - Prefunding: We have not passed start time yet\r\n   * - Funding: Active crowdsale\r\n   * - Success: Minimum funding goal reached\r\n   * - Failure: Minimum funding goal not reached before ending time\r\n   * - Finalized: The finalized has been called and succesfully executed\r\n   * - Refunding: Refunds are loaded on the contract for reclaim.\r\n   */\r\n  enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized, Refunding}\r\n\r\n  // A new investment was made\r\n  event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\r\n\r\n  // Refund was processed for a contributor\r\n  event Refund(address investor, uint weiAmount);\r\n\r\n  // The rules were changed what kind of investments we accept\r\n  event InvestmentPolicyChanged(bool requireCustomerId, bool requiredSignedAddress, address signerAddress);\r\n\r\n  // Address early participation whitelist status changed\r\n  event Whitelisted(address addr, bool status);\r\n\r\n  // Crowdsale end time has been changed\r\n  event EndsAtChanged(uint endsAt);\r\n\r\n  function Crowdsale(address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal) {\r\n\r\n    owner = msg.sender;\r\n\r\n    token = FractionalERC20(_token);\r\n\r\n    setPricingStrategy(_pricingStrategy);\r\n\r\n    multisigWallet = _multisigWallet;\r\n    require(multisigWallet != 0);\r\n    // if(multisigWallet == 0) {\r\n    //     throw;\r\n    // }\r\n\r\n    require(_start != 0);\r\n    // if(_start == 0) {\r\n    //     throw;\r\n    // }\r\n\r\n    startsAt = _start;\r\n\r\n    require(_end != 0);\r\n    // if(_end == 0) {\r\n    //     throw;\r\n    // }\r\n\r\n    endsAt = _end;\r\n\r\n    // Don't mess the dates\r\n    require(startsAt < endsAt);\r\n    // if(startsAt >= endsAt) {\r\n    //     throw;\r\n    // }\r\n\r\n    // Minimum funding goal can be zero\r\n    minimumFundingGoal = _minimumFundingGoal;\r\n  }\r\n\r\n  /**\r\n   * Don't expect to just send in money and get tokens.\r\n   */\r\n  function() payable {\r\n    throw;\r\n  }\r\n\r\n  /**\r\n   * Make an investment.\r\n   *\r\n   * Crowdsale must be running for one to invest.\r\n   * We must have not pressed the emergency brake.\r\n   *\r\n   * @param receiver The Ethereum address who receives the tokens\r\n   * @param customerId (optional) UUID v4 to track the successful payments on the server side\r\n   *\r\n   */\r\n  function investInternal(address receiver, uint128 customerId) stopInEmergency private {\r\n\r\n    // Determine if it's a good time to accept investment from this participant\r\n    if(getState() == State.PreFunding) {\r\n      // Are we whitelisted for early deposit\r\n      require(earlyParticipantWhitelist[receiver]);\r\n      // if(!earlyParticipantWhitelist[receiver]) {\r\n      //   throw;\r\n      // }\r\n    } else if(getState() == State.Funding) {\r\n      // Retail participants can only come in when the crowdsale is running\r\n      // pass\r\n    } else {\r\n      // Unwanted state\r\n      throw;\r\n    }\r\n\r\n    uint weiAmount = msg.value;\r\n    uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());\r\n\r\n    require(tokenAmount != 0);\r\n    // if(tokenAmount == 0) {\r\n    //   // Dust transaction\r\n    //   throw;\r\n    // }\r\n\r\n    if(investedAmountOf[receiver] == 0) {\r\n       // A new investor\r\n       investorCount++;\r\n    }\r\n\r\n    // Update investor\r\n    investedAmountOf[receiver] = safeAdd(investedAmountOf[receiver],weiAmount);\r\n    tokenAmountOf[receiver] = safeAdd(tokenAmountOf[receiver],tokenAmount);\r\n\r\n    // Update totals\r\n    weiRaised = safeAdd(weiRaised,weiAmount);\r\n    tokensSold = safeAdd(tokensSold,tokenAmount);\r\n\r\n    // Check that we did not bust the cap\r\n    require(!isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold));\r\n    // if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) {\r\n    //   throw;\r\n    // }\r\n\r\n    assignTokens(receiver, tokenAmount);\r\n\r\n    // Pocket the money\r\n    if(!multisigWallet.send(weiAmount)) throw;\r\n\r\n    // Tell us invest was success\r\n    Invested(receiver, weiAmount, tokenAmount, customerId);\r\n  }\r\n\r\n  /**\r\n   * Preallocate tokens for the early investors.\r\n   *\r\n   * Preallocated tokens have been sold before the actual crowdsale opens.\r\n   * This function mints the tokens and moves the crowdsale needle.\r\n   *\r\n   * Investor count is not handled; it is assumed this goes for multiple investors\r\n   * and the token distribution happens outside the smart contract flow.\r\n   *\r\n   * No money is exchanged, as the crowdsale team already have received the payment.\r\n   *\r\n   * @param fullTokens tokens as full tokens - decimal places added internally\r\n   * @param weiPrice Price of a single full token in wei\r\n   *\r\n   */\r\n  function preallocate(address receiver, uint fullTokens, uint weiPrice) public onlyOwner {\r\n\r\n    uint tokenAmount = fullTokens * 10**uint(token.decimals());\r\n    uint weiAmount = weiPrice * fullTokens; // This can be also 0, we give out tokens for free\r\n\r\n    weiRaised = safeAdd(weiRaised,weiAmount);\r\n    tokensSold = safeAdd(tokensSold,tokenAmount);\r\n\r\n    investedAmountOf[receiver] = safeAdd(investedAmountOf[receiver],weiAmount);\r\n    tokenAmountOf[receiver] = safeAdd(tokenAmountOf[receiver],tokenAmount);\r\n\r\n    assignTokens(receiver, tokenAmount);\r\n\r\n    // Tell us invest was success\r\n    Invested(receiver, weiAmount, tokenAmount, 0);\r\n  }\r\n\r\n  /**\r\n   * Allow anonymous contributions to this crowdsale.\r\n   */\r\n  // function investWithSignedAddress(address addr, uint128 customerId, uint8 v, bytes32 r, bytes32 s) public payable {\r\n  //    bytes32 hash = sha256(addr);\r\n  //    if (ecrecover(hash, v, r, s) != signerAddress) throw;\r\n  //    require(customerId != 0);\r\n  //    //if(customerId == 0) throw;  // UUIDv4 sanity check\r\n  //    investInternal(addr, customerId);\r\n  // }\r\n\r\n  /**\r\n   * Track who is the customer making the payment so we can send thank you email.\r\n   */\r\n  function investWithCustomerId(address addr, uint128 customerId) public payable {\r\n    require(!requiredSignedAddress);\r\n    //if(requiredSignedAddress) throw; // Crowdsale allows only server-side signed participants\r\n    \r\n    require(customerId != 0);\r\n    //if(customerId == 0) throw;  // UUIDv4 sanity check\r\n    investInternal(addr, customerId);\r\n  }\r\n\r\n  /**\r\n   * Allow anonymous contributions to this crowdsale.\r\n   */\r\n  function invest(address addr) public payable {\r\n    require(!requireCustomerId);\r\n    //if(requireCustomerId) throw; // Crowdsale needs to track partipants for thank you email\r\n    \r\n    require(!requiredSignedAddress);\r\n    //if(requiredSignedAddress) throw; // Crowdsale allows only server-side signed participants\r\n    investInternal(addr, 0);\r\n  }\r\n\r\n  /**\r\n   * Invest to tokens, recognize the payer and clear his address.\r\n   *\r\n   */\r\n  \r\n  // function buyWithSignedAddress(uint128 customerId, uint8 v, bytes32 r, bytes32 s) public payable {\r\n  //   investWithSignedAddress(msg.sender, customerId, v, r, s);\r\n  // }\r\n\r\n  /**\r\n   * Invest to tokens, recognize the payer.\r\n   *\r\n   */\r\n  function buyWithCustomerId(uint128 customerId) public payable {\r\n    investWithCustomerId(msg.sender, customerId);\r\n  }\r\n\r\n  /**\r\n   * The basic entry point to participate the crowdsale process.\r\n   *\r\n   * Pay for funding, get invested tokens back in the sender address.\r\n   */\r\n  function buy() public payable {\r\n    invest(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * Finalize a succcesful crowdsale.\r\n   *\r\n   * The owner can triggre a call the contract that provides post-crowdsale actions, like releasing the tokens.\r\n   */\r\n  function finalize() public inState(State.Success) onlyOwner stopInEmergency {\r\n\r\n    // Already finalized\r\n    require(!finalized);\r\n    // if(finalized) {\r\n    //   throw;\r\n    // }\r\n\r\n    // Finalizing is optional. We only call it if we are given a finalizing agent.\r\n    if(address(finalizeAgent) != 0) {\r\n      finalizeAgent.finalizeCrowdsale();\r\n    }\r\n\r\n    finalized = true;\r\n  }\r\n\r\n  /**\r\n   * Allow to (re)set finalize agent.\r\n   *\r\n   * Design choice: no state restrictions on setting this, so that we can fix fat finger mistakes.\r\n   */\r\n  function setFinalizeAgent(FinalizeAgent addr) onlyOwner {\r\n    finalizeAgent = addr;\r\n\r\n    // Don't allow setting bad agent\r\n    require(finalizeAgent.isFinalizeAgent());\r\n    // if(!finalizeAgent.isFinalizeAgent()) {\r\n    //   throw;\r\n    // }\r\n  }\r\n\r\n  /**\r\n   * Set policy do we need to have server-side customer ids for the investments.\r\n   *\r\n   */\r\n  function setRequireCustomerId(bool value) onlyOwner {\r\n    requireCustomerId = value;\r\n    InvestmentPolicyChanged(requireCustomerId, requiredSignedAddress, signerAddress);\r\n  }\r\n\r\n  /**\r\n   * Set policy if all investors must be cleared on the server side first.\r\n   *\r\n   * This is e.g. for the accredited investor clearing.\r\n   *\r\n   */\r\n  // function setRequireSignedAddress(bool value, address _signerAddress) onlyOwner {\r\n  //   requiredSignedAddress = value;\r\n  //   signerAddress = _signerAddress;\r\n  //   InvestmentPolicyChanged(requireCustomerId, requiredSignedAddress, signerAddress);\r\n  // }\r\n\r\n  /**\r\n   * Allow addresses to do early participation.\r\n   *\r\n   * TODO: Fix spelling error in the name\r\n   */\r\n  function setEarlyParicipantWhitelist(address addr, bool status) onlyOwner {\r\n    earlyParticipantWhitelist[addr] = status;\r\n    Whitelisted(addr, status);\r\n  }\r\n\r\n  /**\r\n   * Allow crowdsale owner to close early or extend the crowdsale.\r\n   *\r\n   * This is useful e.g. for a manual soft cap implementation:\r\n   * - after X amount is reached determine manual closing\r\n   *\r\n   * This may put the crowdsale to an invalid state,\r\n   * but we trust owners know what they are doing.\r\n   *\r\n   */\r\n  function setEndsAt(uint time) onlyOwner {\r\n\r\n    if(now > time) {\r\n      throw; // Don't change past\r\n    }\r\n\r\n    endsAt = time;\r\n    EndsAtChanged(endsAt);\r\n  }\r\n\r\n  /**\r\n   * Allow to (re)set pricing strategy.\r\n   *\r\n   * Design choice: no state restrictions on the set, so that we can fix fat finger mistakes.\r\n   */\r\n  function setPricingStrategy(PricingStrategy _pricingStrategy) onlyOwner {\r\n    pricingStrategy = _pricingStrategy;\r\n\r\n    // Don't allow setting bad agent\r\n    require(pricingStrategy.isPricingStrategy());\r\n    // if(!pricingStrategy.isPricingStrategy()) {\r\n    //   throw;\r\n    // }\r\n  }\r\n\r\n  /**\r\n   * Allow to change the team multisig address in the case of emergency.\r\n   *\r\n   * This allows to save a deployed crowdsale wallet in the case the crowdsale has not yet begun\r\n   * (we have done only few test transactions). After the crowdsale is going\r\n   * then multisig address stays locked for the safety reasons.\r\n   */\r\n  function setMultisig(address addr) public onlyOwner {\r\n\r\n    // Change\r\n    if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {\r\n      throw;\r\n    }\r\n\r\n    multisigWallet = addr;\r\n  }\r\n\r\n  /**\r\n   * Allow load refunds back on the contract for the refunding.\r\n   *\r\n   * The team can transfer the funds back on the smart contract in the case the minimum goal was not reached..\r\n   */\r\n  function loadRefund() public payable inState(State.Failure) {\r\n    require(msg.value != 0);\r\n    //if(msg.value == 0) throw;\r\n    loadedRefund = safeAdd(loadedRefund,msg.value);\r\n  }\r\n\r\n  /**\r\n   * Investors can claim refund.\r\n   */\r\n  function refund() public inState(State.Refunding) {\r\n    uint256 weiValue = investedAmountOf[msg.sender];\r\n    require(weiValue != 0);\r\n    //if (weiValue == 0) throw;\r\n    investedAmountOf[msg.sender] = 0;\r\n    weiRefunded = safeAdd(weiRefunded,weiValue);\r\n    Refund(msg.sender, weiValue);\r\n    if (!msg.sender.send(weiValue)) throw;\r\n  }\r\n\r\n  /**\r\n   * @return true if the crowdsale has raised enough money to be a succes\r\n   */\r\n  function isMinimumGoalReached() public constant returns (bool reached) {\r\n    return weiRaised >= minimumFundingGoal;\r\n  }\r\n\r\n  /**\r\n   * Check if the contract relationship looks good.\r\n   */\r\n  function isFinalizerSane() public constant returns (bool sane) {\r\n    return finalizeAgent.isSane();\r\n  }\r\n\r\n  /**\r\n   * Check if the contract relationship looks good.\r\n   */\r\n  function isPricingSane() public constant returns (bool sane) {\r\n    return pricingStrategy.isSane(address(this));\r\n  }\r\n\r\n  /**\r\n   * Crowdfund state machine management.\r\n   *\r\n   * We make it a function and do not assign the result to a variable, so there is no chance of the variable being stale.\r\n   */\r\n  function getState() public constant returns (State) {\r\n    if(finalized) return State.Finalized;\r\n    else if (address(finalizeAgent) == 0) return State.Preparing;\r\n    else if (!finalizeAgent.isSane()) return State.Preparing;\r\n    else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\r\n    else if (block.timestamp < startsAt) return State.PreFunding;\r\n    else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\r\n    else if (isMinimumGoalReached()) return State.Success;\r\n    else if (!isMinimumGoalReached() && weiRaised > 0 && loadedRefund >= weiRaised) return State.Refunding;\r\n    else return State.Failure;\r\n  }\r\n\r\n  /** This is for manual testing of multisig wallet interaction */\r\n  function setOwnerTestValue(uint val) onlyOwner {\r\n    ownerTestValue = val;\r\n  }\r\n\r\n  /** Interface marker. */\r\n  function isCrowdsale() public constant returns (bool) {\r\n    return true;\r\n  }\r\n\r\n  //\r\n  // Modifiers\r\n  //\r\n\r\n  /** Modified allowing execution only if the crowdsale is currently running.  */\r\n  modifier inState(State state) {\r\n    require(getState() == state);\r\n    //if(getState() != state) throw;\r\n    _;\r\n  }\r\n\r\n\r\n  //\r\n  // Abstract functions\r\n  //\r\n\r\n  /**\r\n   * Check if the current invested breaks our cap rules.\r\n   *\r\n   *\r\n   * The child contract must define their own cap setting rules.\r\n   * We allow a lot of flexibility through different capping strategies (ETH, token count)\r\n   * Called from invest().\r\n   *\r\n   * @param weiAmount The amount of wei the investor tries to invest in the current transaction\r\n   * @param tokenAmount The amount of tokens we try to give to the investor in the current transaction\r\n   * @param weiRaisedTotal What would be our total raised balance after this transaction\r\n   * @param tokensSoldTotal What would be our total sold tokens count after this transaction\r\n   *\r\n   * @return true if taking this investment would break our cap rules\r\n   */\r\n  function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) constant returns (bool limitBroken);\r\n  /**\r\n   * Check if the current crowdsale is full and we can no longer sell any tokens.\r\n   */\r\n  function isCrowdsaleFull() public constant returns (bool);\r\n\r\n  /**\r\n   * Create new tokens or transfer issued tokens to the investor depending on the cap model.\r\n   */\r\n  function assignTokens(address receiver, uint tokenAmount) private;\r\n}\r\n\r\n/**\r\n * At the end of the successful crowdsale allocate % bonus of tokens to the team.\r\n *\r\n * Unlock tokens.\r\n *\r\n * BonusAllocationFinal must be set as the minting agent for the MintableToken.\r\n *\r\n */\r\ncontract BonusFinalizeAgent is FinalizeAgent, SafeMathLib {\r\n\r\n  CrowdsaleToken public token;\r\n  Crowdsale public crowdsale;\r\n\r\n  /** Total percent of tokens minted to the team at the end of the sale as base points (0.0001) */\r\n  uint public totalMembers;\r\n  uint public allocatedBonus;\r\n  mapping (address=>uint) bonusOf;\r\n  /** Where we move the tokens at the end of the sale. */\r\n  address[] public teamAddresses;\r\n\r\n\r\n  function BonusFinalizeAgent(CrowdsaleToken _token, Crowdsale _crowdsale, uint[] _bonusBasePoints, address[] _teamAddresses) {\r\n    token = _token;\r\n    crowdsale = _crowdsale;\r\n\r\n    //crowdsale address must not be 0\r\n    require(address(crowdsale) != 0);\r\n\r\n    //bonus & team address array size must match\r\n    require(_bonusBasePoints.length == _teamAddresses.length);\r\n\r\n    totalMembers = _teamAddresses.length;\r\n    teamAddresses = _teamAddresses;\r\n    \r\n    //if any of the bonus is 0 throw\r\n    // otherwise sum it up in totalAllocatedBonus\r\n    for (uint i=0;i<totalMembers;i++){\r\n      require(_bonusBasePoints[i] != 0);\r\n      //if(_bonusBasePoints[i] == 0) throw;\r\n    }\r\n\r\n    //if any of the address is 0 or invalid throw\r\n    //otherwise initialize the bonusOf array\r\n    for (uint j=0;j<totalMembers;j++){\r\n      require(_teamAddresses[j] != 0);\r\n      //if(_teamAddresses[j] == 0) throw;\r\n      bonusOf[_teamAddresses[j]] = _bonusBasePoints[j];\r\n    }\r\n  }\r\n\r\n  /* Can we run finalize properly */\r\n  function isSane() public constant returns (bool) {\r\n    return (token.mintAgents(address(this)) == true) && (token.releaseAgent() == address(this));\r\n  }\r\n\r\n  /** Called once by crowdsale finalize() if the sale was success. */\r\n  function finalizeCrowdsale() {\r\n\r\n    // if finalized is not being called from the crowdsale \r\n    // contract then throw\r\n    require(msg.sender == address(crowdsale));\r\n\r\n    // if(msg.sender != address(crowdsale)) {\r\n    //   throw;\r\n    // }\r\n\r\n    // get the total sold tokens count.\r\n    uint tokensSold = crowdsale.tokensSold();\r\n\r\n    for (uint i=0;i<totalMembers;i++){\r\n      allocatedBonus = safeMul(tokensSold, bonusOf[teamAddresses[i]]) / 10000;\r\n      // move tokens to the team multisig wallet\r\n      token.mint(teamAddresses[i], allocatedBonus);\r\n    }\r\n\r\n    // Make token transferable\r\n    // realease them in the wild\r\n    // Hell yeah!!! we did it.\r\n    token.releaseTokenTransfer();\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * ICO crowdsale contract that is capped by amout of ETH.\r\n *\r\n * - Tokens are dynamically created during the crowdsale\r\n *\r\n *\r\n */\r\ncontract MintedEthCappedCrowdsale is Crowdsale {\r\n\r\n  /* Maximum amount of wei this crowdsale can raise. */\r\n  uint public weiCap;\r\n\r\n  function MintedEthCappedCrowdsale(address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, uint _weiCap) Crowdsale(_token, _pricingStrategy, _multisigWallet, _start, _end, _minimumFundingGoal) {\r\n    weiCap = _weiCap;\r\n  }\r\n\r\n  /**\r\n   * Called from invest() to confirm if the curret investment does not break our cap rule.\r\n   */\r\n  function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) constant returns (bool limitBroken) {\r\n    return weiRaisedTotal > weiCap;\r\n  }\r\n\r\n  function isCrowdsaleFull() public constant returns (bool) {\r\n    return weiRaised >= weiCap;\r\n  }\r\n\r\n  /**\r\n   * Dynamically create tokens and assign them to the investor.\r\n   */\r\n  function assignTokens(address receiver, uint tokenAmount) private {\r\n    MintableToken mintableToken = MintableToken(token);\r\n    mintableToken.mint(receiver, tokenAmount);\r\n  }\r\n}\r\n\r\n/** Tranche based pricing with special support for pre-ico deals.\r\n *      Implementing \"first price\" tranches, meaning, that if byers order is\r\n *      covering more than one tranche, the price of the lowest tranche will apply\r\n *      to the whole order.\r\n */\r\ncontract EthTranchePricing is PricingStrategy, Ownable, SafeMathLib {\r\n\r\n  uint public constant MAX_TRANCHES = 10;\r\n \r\n \r\n  // This contains all pre-ICO addresses, and their prices (weis per token)\r\n  mapping (address => uint) public preicoAddresses;\r\n\r\n  /**\r\n  * Define pricing schedule using tranches.\r\n  */\r\n\r\n  struct Tranche {\r\n      // Amount in weis when this tranche becomes active\r\n      uint amount;\r\n      // How many tokens per wei you will get while this tranche is active\r\n      uint price;\r\n  }\r\n\r\n  // Store tranches in a fixed array, so that it can be seen in a blockchain explorer\r\n  // Tranche 0 is always (0, 0)\r\n  // (TODO: change this when we confirm dynamic arrays are explorable)\r\n  Tranche[10] public tranches;\r\n\r\n  // How many active tranches we have\r\n  uint public trancheCount;\r\n\r\n  /// @dev Contruction, creating a list of tranches\r\n  /// @param _tranches uint[] tranches Pairs of (start amount, price)\r\n  function EthTranchePricing(uint[] _tranches) {\r\n    // [ 0, 666666666666666,\r\n    //   3000000000000000000000, 769230769230769,\r\n    //   5000000000000000000000, 909090909090909,\r\n    //   8000000000000000000000, 952380952380952,\r\n    //   2000000000000000000000, 1000000000000000 ]\r\n    // Need to have tuples, length check\r\n    require(!(_tranches.length % 2 == 1 || _tranches.length >= MAX_TRANCHES*2));\r\n    // if(_tranches.length % 2 == 1 || _tranches.length >= MAX_TRANCHES*2) {\r\n    //   throw;\r\n    // }\r\n    trancheCount = _tranches.length / 2;\r\n    uint highestAmount = 0;\r\n    for(uint i=0; i<_tranches.length/2; i++) {\r\n      tranches[i].amount = _tranches[i*2];\r\n      tranches[i].price = _tranches[i*2+1];\r\n      // No invalid steps\r\n      require(!((highestAmount != 0) && (tranches[i].amount <= highestAmount)));\r\n      // if((highestAmount != 0) && (tranches[i].amount <= highestAmount)) {\r\n      //   throw;\r\n      // }\r\n      highestAmount = tranches[i].amount;\r\n    }\r\n\r\n    // We need to start from zero, otherwise we blow up our deployment\r\n    require(tranches[0].amount == 0);\r\n    // if(tranches[0].amount != 0) {\r\n    //   throw;\r\n    // }\r\n\r\n    // Last tranche price must be zero, terminating the crowdale\r\n    require(tranches[trancheCount-1].price == 0);\r\n    // if(tranches[trancheCount-1].price != 0) {\r\n    //   throw;\r\n    // }\r\n  }\r\n\r\n  /// @dev This is invoked once for every pre-ICO address, set pricePerToken\r\n  ///      to 0 to disable\r\n  /// @param preicoAddress PresaleFundCollector address\r\n  /// @param pricePerToken How many weis one token cost for pre-ico investors\r\n  function setPreicoAddress(address preicoAddress, uint pricePerToken)\r\n    public\r\n    onlyOwner\r\n  {\r\n    preicoAddresses[preicoAddress] = pricePerToken;\r\n  }\r\n\r\n  /// @dev Iterate through tranches. You reach end of tranches when price = 0\r\n  /// @return tuple (time, price)\r\n  function getTranche(uint n) public constant returns (uint, uint) {\r\n    return (tranches[n].amount, tranches[n].price);\r\n  }\r\n\r\n  function getFirstTranche() private constant returns (Tranche) {\r\n    return tranches[0];\r\n  }\r\n\r\n  function getLastTranche() private constant returns (Tranche) {\r\n    return tranches[trancheCount-1];\r\n  }\r\n\r\n  function getPricingStartsAt() public constant returns (uint) {\r\n    return getFirstTranche().amount;\r\n  }\r\n\r\n  function getPricingEndsAt() public constant returns (uint) {\r\n    return getLastTranche().amount;\r\n  }\r\n\r\n  function isSane(address _crowdsale) public constant returns(bool) {\r\n    // Our tranches are not bound by time, so we can't really check are we sane\r\n    // so we presume we are ;)\r\n    // In the future we could save and track raised tokens, and compare it to\r\n    // the Crowdsale contract.\r\n    return true;\r\n  }\r\n\r\n  /// @dev Get the current tranche or bail out if we are not in the tranche periods.\r\n  /// @param weiRaised total amount of weis raised, for calculating the current tranche\r\n  /// @return {[type]} [description]\r\n  function getCurrentTranche(uint weiRaised) private constant returns (Tranche) {\r\n    uint i;\r\n    for(i=0; i < tranches.length; i++) {\r\n      if(weiRaised < tranches[i].amount) {\r\n        return tranches[i-1];\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @dev Get the current price.\r\n  /// @param weiRaised total amount of weis raised, for calculating the current tranche\r\n  /// @return The current price or 0 if we are outside trache ranges\r\n  function getCurrentPrice(uint weiRaised) public constant returns (uint result) {\r\n    return getCurrentTranche(weiRaised).price;\r\n  }\r\n\r\n  /// @dev Calculate the current price for buy in amount.\r\n  function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint) {\r\n\r\n    uint multiplier = 10 ** decimals;\r\n\r\n    // This investor is coming through pre-ico\r\n    if(preicoAddresses[msgSender] > 0) {\r\n      return safeMul(value, multiplier) / preicoAddresses[msgSender];\r\n    }\r\n\r\n    uint price = getCurrentPrice(weiRaised);\r\n    \r\n    return safeMul(value, multiplier) / price;\r\n  }\r\n\r\n  function() payable {\r\n    throw; // No money on this contract\r\n  }\r\n\r\n}", "OptimizationUsed": "1", "ContractName": "CrowdsaleToken", "ByteCode": "0x606060405236156101b45763ffffffff7c010000000000000000000000000000000000000000000000000000000060003504166302f652a381146101b657806305d2035b146101d957806306fdde03146101fd578063095ea7b31461028d57806318160ddd146102c057806323b872dd146102e257806329ff4f531461031b578063313ce5671461033957806340c10f191461035f57806342c1867b1461038057806343214675146103b057806345977d03146103d35780634eee966f146103e85780635de4ccb01461047d5780635f412d4f146104a9578063600440cb146104bb57806370a08231146104e757806379ba5097146105155780638444b39114610527578063867c28571461055b5780638da5cb5b1461058b57806395d89b41146105b757806396132521146106475780639738968c1461066b578063a293d1e81461068f578063a9059cbb146106b7578063c752ff62146106ea578063d05c78da1461070c578063d1f276d314610734578063d4ee1d9014610760578063d7e7088a1461078c578063dd62ed3e146107aa578063e6cb9013146107de578063f2fde38b14610806578063ffeb7d7514610824575bfe5b34156101be57fe5b6101d7600160a060020a03600435166024351515610842565b005b34156101e157fe5b6101e96108a5565b604080519115158252519081900360200190f35b341561020557fe5b61020d6108ae565b604080516020808252835181830152835191928392908301918501908083838215610253575b80518252602083111561025357601f199092019160209182019101610233565b505050905090810190601f16801561027f5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b341561029557fe5b6101e9600160a060020a036004351660243561093c565b604080519115158252519081900360200190f35b34156102c857fe5b6102d06109e3565b60408051918252519081900360200190f35b34156102ea57fe5b6101e9600160a060020a03600435811690602435166044356109e9565b604080519115158252519081900360200190f35b341561032357fe5b6101d7600160a060020a0360043516610a41565b005b341561034157fe5b610349610aa7565b6040805160ff9092168252519081900360200190f35b341561036757fe5b6101d7600160a060020a0360043516602435610ab0565b005b341561038857fe5b6101e9600160a060020a0360043516610b75565b604080519115158252519081900360200190f35b34156103b857fe5b6101d7600160a060020a03600435166024351515610b8a565b005b34156103db57fe5b6101d7600435610c1e565b005b34156103f057fe5b6101d7600480803590602001908201803590602001908080601f0160208091040260200160405190810160405280939291908181526020018383808284375050604080516020601f89358b01803591820183900483028401830190945280835297999881019791965091820194509250829150840183828082843750949650610d8e95505050505050565b005b341561048557fe5b61048d610f02565b60408051600160a060020a039092168252519081900360200190f35b34156104b157fe5b6101d7610f11565b005b34156104c357fe5b61048d610f46565b60408051600160a060020a039092168252519081900360200190f35b34156104ef57fe5b6102d0600160a060020a0360043516610f55565b60408051918252519081900360200190f35b341561051d57fe5b6101d7610f74565b005b341561052f57fe5b610537611001565b6040518082600481111561054757fe5b60ff16815260200191505060405180910390f35b341561056357fe5b6101e9600160a060020a036004351661104e565b604080519115158252519081900360200190f35b341561059357fe5b61048d611063565b60408051600160a060020a039092168252519081900360200190f35b34156105bf57fe5b61020d611072565b604080516020808252835181830152835191928392908301918501908083838215610253575b80518252602083111561025357601f199092019160209182019101610233565b505050905090810190601f16801561027f5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b341561064f57fe5b6101e9611100565b604080519115158252519081900360200190f35b341561067357fe5b6101e9611110565b604080519115158252519081900360200190f35b341561069757fe5b6102d0600435602435611136565b60408051918252519081900360200190f35b34156106bf57fe5b6101e9600160a060020a036004351660243561114d565b604080519115158252519081900360200190f35b34156106f257fe5b6102d06111a3565b60408051918252519081900360200190f35b341561071457fe5b6102d06004356024356111a9565b60408051918252519081900360200190f35b341561073c57fe5b61048d6111d8565b60408051600160a060020a039092168252519081900360200190f35b341561076857fe5b61048d6111e7565b60408051600160a060020a039092168252519081900360200190f35b341561079457fe5b6101d7600160a060020a03600435166111f6565b005b34156107b257fe5b6102d0600160a060020a03600435811690602435166113d3565b60408051918252519081900360200190f35b34156107e657fe5b6102d0600435602435611400565b60408051918252519081900360200190f35b341561080e57fe5b6101d7600160a060020a036004351661141a565b005b341561082c57fe5b6101d7600160a060020a0360043516611463565b005b60035433600160a060020a0390811691161461085e5760006000fd5b60055460009060a060020a900460ff16156108795760006000fd5b600160a060020a0383166000908152600660205260409020805460ff19168315151790555b5b505b5050565b60075460ff1681565b600c805460408051602060026001851615610100026000190190941693909304601f810184900484028201840190925281815292918301828280156109345780601f1061090957610100808354040283529160200191610934565b820191906000526020600020905b81548152906001019060200180831161091757829003601f168201915b505050505081565b600081158015906109715750600160a060020a0333811660009081526002602090815260408083209387168352929052205415155b1561097c5760006000fd5b600160a060020a03338116600081815260026020908152604080832094881680845294825291829020869055815186815291517f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b9259281900390910190a35060015b92915050565b60005481565b600554600090849060a060020a900460ff161515610a2957600160a060020a03811660009081526006602052604090205460ff161515610a295760006000fd5b5b610a358585856114c1565b91505b5b509392505050565b60035433600160a060020a03908116911614610a5d5760006000fd5b60055460009060a060020a900460ff1615610a785760006000fd5b6005805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0384161790555b5b505b50565b600e5460ff1681565b600160a060020a03331660009081526008602052604090205460ff161515610ad85760006000fd5b60075460ff1615610ae95760006000fd5b610af560005482611400565b6000908155600160a060020a038316815260016020526040902054610b1a9082611400565b600160a060020a03831660008181526001602090815260408083209490945583518581529351929391927fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef9281900390910190a35b5b5b5050565b60086020526000908152604090205460ff1681565b60035433600160a060020a03908116911614610ba65760006000fd5b60075460ff1615610bb75760006000fd5b600160a060020a038216600081815260086020908152604091829020805460ff191685151590811790915582519384529083015280517f4b0adf6c802794c7dde28a08a4e07131abcff3bf9603cd71f14f90bec7865efa9281900390910190a15b5b5b5050565b6000610c28611001565b905060035b816004811115610c3957fe5b1480610c51575060045b816004811115610c4f57fe5b145b1515610c5d5760006000fd5b811515610c6a5760006000fd5b600160a060020a033316600090815260016020526040902054610c8d9083611136565b600160a060020a03331660009081526001602052604081209190915554610cb49083611136565b600055600b54610cc49083611400565b600b55600a54604080517f753e88e5000000000000000000000000000000000000000000000000000000008152600160a060020a033381166004830152602482018690529151919092169163753e88e591604480830192600092919082900301818387803b1515610d3157fe5b6102c65a03f11515610d3f57fe5b5050600a54604080518581529051600160a060020a03928316935033909216917f7e5c344a8141a805725cb476f76c6953b842222b967edd1f78ddb6e8b3f397ac9181900360200190a35b5050565b60035433600160a060020a03908116911614610daa5760006000fd5b8151610dbd90600c90602085019061178c565b508051610dd190600d90602084019061178c565b5060408051818152600c8054600260001961010060018416150201909116049282018390527fd131ab1e6f279deea74e13a18477e13e2107deb6dc8ae955648948be5841fb46929091600d9181906020820190606083019086908015610e785780601f10610e4d57610100808354040283529160200191610e78565b820191906000526020600020905b815481529060010190602001808311610e5b57829003601f168201915b5050838103825284546002600019610100600184161502019091160480825260209091019085908015610eec5780601f10610ec157610100808354040283529160200191610eec565b820191906000526020600020905b815481529060010190602001808311610ecf57829003601f168201915b505094505050505060405180910390a15b5b5050565b600a54600160a060020a031681565b60055433600160a060020a03908116911614610f2d5760006000fd5b6007805460ff19166001179055610f4261162e565b5b5b565b600954600160a060020a031681565b600160a060020a0381166000908152600160205260409020545b919050565b60045433600160a060020a03908116911614610f905760006000fd5b600454600354604051600160a060020a0392831692909116907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a36004546003805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a039092169190911790555b565b600061100b611110565b151561101957506001611048565b600a54600160a060020a0316151561103357506002611048565b600b54151561104457506003611048565b5060045b5b5b5b90565b60066020526000908152604090205460ff1681565b600354600160a060020a031681565b600d805460408051602060026001851615610100026000190190941693909304601f810184900484028201840190925281815292918301828280156109345780601f1061090957610100808354040283529160200191610934565b820191906000526020600020905b81548152906001019060200180831161091757829003601f168201915b505050505081565b60055460a060020a900460ff1681565b60055460009060a060020a900460ff16801561112f575061112f611672565b5b90505b90565b60008282111561114257fe5b508082035b92915050565b600554600090339060a060020a900460ff16151561118d57600160a060020a03811660009081526006602052604090205460ff16151561118d5760006000fd5b5b6111988484611678565b91505b5b5092915050565b600b5481565b60008282028315806111c557508284828115156111c257fe5b04145b15156111cd57fe5b8091505b5092915050565b600554600160a060020a031681565b600454600160a060020a031681565b6111fe611110565b151561120a5760006000fd5b600160a060020a03811615156112205760006000fd5b60095433600160a060020a0390811691161461123c5760006000fd5b60045b611247611001565b600481111561125257fe5b141561125e5760006000fd5b600a805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a038381169190911791829055604080516000602091820181905282517f61d3d7a6000000000000000000000000000000000000000000000000000000008152925194909316936361d3d7a6936004808501948390030190829087803b15156112e457fe5b6102c65a03f115156112f257fe5b505060405151151590506113065760006000fd5b60008054600a5460408051602090810185905281517f4b2ba0dd00000000000000000000000000000000000000000000000000000000815291519394600160a060020a0390931693634b2ba0dd936004808501948390030190829087803b151561136c57fe5b6102c65a03f1151561137a57fe5b5050604051519190911490506113905760006000fd5b600a5460408051600160a060020a039092168252517f7845d5aa74cc410e35571258d954f23b82276e160fe8c188fa80566580f279cc9181900360200190a15b50565b600160a060020a038083166000908152600260209081526040808320938516835292905220545b92915050565b6000828201838110156111cd57fe5b8091505b5092915050565b60035433600160a060020a039081169116146114365760006000fd5b6004805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0383161790555b5b50565b600160a060020a03811615156114795760006000fd5b60095433600160a060020a039081169116146114955760006000fd5b6009805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0383161790555b50565b600160a060020a0380841660008181526002602090815260408083203390951683529381528382205492825260019052918220548390108015906115055750828110155b80156115115750600083115b80156115365750600160a060020a038416600090815260016020526040902054838101115b1561161c57600160a060020a03841660009081526001602052604090205461155e9084611400565b600160a060020a03808616600090815260016020526040808220939093559087168152205461158d9084611136565b600160a060020a0386166000908152600160205260409020556115b08184611136565b600160a060020a038087166000818152600260209081526040808320338616845282529182902094909455805187815290519288169391927fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef929181900390910190a360019150610a38565b60009150610a38565b5b509392505050565b60055433600160a060020a0390811691161461164a5760006000fd5b6005805474ff0000000000000000000000000000000000000000191660a060020a1790555b5b565b60015b90565b600160a060020a0333166000908152600160205260408120548290108015906116a15750600082115b80156116c65750600160a060020a038316600090815260016020526040902054828101115b1561177d57600160a060020a0333166000908152600160205260409020546116ee9083611136565b600160a060020a03338116600090815260016020526040808220939093559085168152205461171d9083611400565b600160a060020a038085166000818152600160209081526040918290209490945580518681529051919333909316927fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef92918290030190a35060016109dd565b5060006109dd565b5b92915050565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f106117cd57805160ff19168380011785556117fa565b828001600101855582156117fa579182015b828111156117fa5782518255916020019190600101906117df565b5b5061180792915061180b565b5090565b61104891905b808211156118075760008155600101611811565b5090565b905600a165627a7a72305820c2472a96c6479f1e7c1d773671b9e912525eb9cd0de22f2737804e0ca947c8030029"}