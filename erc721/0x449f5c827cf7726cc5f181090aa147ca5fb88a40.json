{"Runs": "200", "SwarmSource": "bzzr://acd2f88c4266d21dc364824757dc3445dbd6bc4c15a90199e46a73d2a53ea2cf", "ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getActiveContracts\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_approved\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"add\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"deactivateContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"migrate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"migrationIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"activateContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"replaceOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_formerContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"LogOwnerChange\",\"type\":\"event\"}]", "Library": "", "CompilerVersion": "v0.4.21+commit.dfe3193c", "ConstructorArguments": "00000000000000000000000025d466f0e7da4ec2f7201309e5416951d1e241a2", "SourceCode": "pragma solidity ^0.4.19;\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard\r\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd\r\ninterface ERC721 /* is ERC165 */ {\r\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\r\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\r\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\r\n    ///  may be created and assigned without emitting Transfer. At the time of\r\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n\r\n    /// @dev This emits when the approved address for an NFT is changed or\r\n    ///  reaffirmed. The zero address indicates there is no approved address.\r\n    ///  When a Transfer event emits, this also indicates that the approved\r\n    ///  address for that NFT (if any) is reset to none.\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\r\n\r\n    /// @dev This emits when an operator is enabled or disabled for an owner.\r\n    ///  The operator can manage all NFTs of the owner.\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    /// @notice Count all NFTs assigned to an owner\r\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\r\n    ///  function throws for queries about the zero address.\r\n    /// @param _owner An address for whom to query the balance\r\n    /// @return The number of NFTs owned by `_owner`, possibly zero\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n\r\n    /// @notice Find the owner of an NFT\r\n    /// @param _tokenId The identifier for an NFT\r\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\r\n    ///  about them do throw.\r\n    /// @return The address of the owner of the NFT\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n    ///  `onERC721Received` on `_to` and throws if the return value is not\r\n    ///  `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    /// @param data Additional data with no specified format, sent in call to `_to`\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external;\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev This works identically to the other function with an extra data parameter,\r\n    ///  except this function just sets data to \"\"\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;\r\n\r\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n    ///  THEY MAY BE PERMANENTLY LOST\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\r\n\r\n    /// @notice Set or reaffirm the approved address for an NFT\r\n    /// @dev The zero address indicates there is no approved address.\r\n    /// @dev Throws unless `msg.sender` is the current NFT owner, or an authorized\r\n    ///  operator of the current owner.\r\n    /// @param _approved The new approved NFT controller\r\n    /// @param _tokenId The NFT to approve\r\n    function approve(address _approved, uint256 _tokenId) external;\r\n\r\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\r\n    ///  all your assets.\r\n    /// @dev Throws unless `msg.sender` is the current NFT owner.\r\n    /// @dev Emits the ApprovalForAll event\r\n    /// @param _operator Address to add to the set of authorized operators.\r\n    /// @param _approved True if the operators is approved, false to revoke approval\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n    /// @notice Get the approved address for a single NFT\r\n    /// @dev Throws if `_tokenId` is not a valid NFT\r\n    /// @param _tokenId The NFT to find the approved address for\r\n    /// @return The approved address for this NFT, or the zero address if there is none\r\n    function getApproved(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Query if an address is an authorized operator for another address\r\n    /// @param _owner The address that owns the NFTs\r\n    /// @param _operator The address that acts on behalf of the owner\r\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n}\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n///  Note: the ERC-165 identifier for this interface is 0x780e9d63\r\ninterface ERC721Enumerable /* is ERC721 */ {\r\n  /// @notice Count NFTs tracked by this contract\r\n  /// @return A count of valid NFTs tracked by this contract, where each one of\r\n  ///  them has an assigned and queryable owner not equal to the zero address\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  /// @notice Enumerate valid NFTs\r\n  /// @dev Throws if `_index` >= `totalSupply()`.\r\n  /// @param _index A counter less than `totalSupply()`\r\n  /// @return The token identifier for the `_index`th NFT,\r\n  ///  (sort order not specified)\r\n  function tokenByIndex(uint256 _index) external view returns (uint256);\r\n\r\n  /// @notice Enumerate NFTs assigned to an owner\r\n  /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\r\n  ///  `_owner` is the zero address, representing invalid NFTs.\r\n  /// @param _owner An address where we are interested in NFTs owned by them\r\n  /// @param _index A counter less than `balanceOf(_owner)`\r\n  /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\r\n  ///   (sort order not specified)\r\n  function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\r\n}\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n///  Note: the ERC-165 identifier for this interface is 0x5b5e139f\r\ninterface ERC721Metadata /* is ERC721 */ {\r\n    /// @notice A descriptive name for a collection of NFTs in this contract\r\n    function name() external pure returns (string _name);\r\n\r\n    /// @notice An abbreviated name for NFTs in this contract\r\n    function symbol() external pure returns (string _symbol);\r\n\r\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\r\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\r\n    ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\r\n    ///  Metadata JSON Schema\".\r\n    function tokenURI(uint256 _tokenId) external view returns (string);\r\n}\r\n\r\n/// @dev Note: the ERC-165 identifier for this interface is 0xf0b9e5ba\r\ninterface ERC721TokenReceiver {\r\n    /// @notice Handle the receipt of an NFT\r\n    /// @dev The ERC721 smart contract calls this function on the recipient\r\n    ///  after a `transfer`. This function MAY throw to revert and reject the\r\n    ///  transfer. This function MUST use 50,000 gas or less. Return of other\r\n    ///  than the magic value MUST result in the transaction being reverted.\r\n    ///  Note: the contract address is always the message sender.\r\n    /// @param _from The sending address \r\n    /// @param _tokenId The NFT identifier which is being transferred\r\n    /// @param data Additional data with no specified format\r\n    /// @return `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`\r\n    ///  unless throwing\r\n    function onERC721Received(address _from, uint256 _tokenId, bytes data) external returns(bytes4);\r\n}\r\n\r\ncontract Ownable {\r\n    address private owner;\r\n\r\n    event LogOwnerChange(address _owner);\r\n\r\n    // Modify method to only allow calls from the owner of the contract.\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * Replace the contract owner with a new owner.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * _owner : address\r\n     *     The address to replace the current owner with.\r\n     */\r\n    function replaceOwner(address _owner) external onlyOwner {\r\n        owner = _owner;\r\n\r\n        LogOwnerChange(_owner);\r\n    }\r\n}\r\n\r\ncontract Controllable is Ownable {\r\n    // Mapping of a contract address to its position in the list of active\r\n    // contracts. This allows an O(1) look-up of the contract address compared\r\n    // to a linear search within an array.\r\n    mapping(address => uint256) private contractIndices;\r\n\r\n    // The list of contracts that are allowed to call the contract-restricted\r\n    // methods of contracts that extend this `Controllable` contract.\r\n    address[] private contracts;\r\n\r\n    /**\r\n     * Modify method to only allow calls from active contract addresses.\r\n     *\r\n     * Notes\r\n     * -----\r\n     * The zero address is considered an inactive address, as it is impossible\r\n     * for users to send a call from that address.\r\n     */\r\n    modifier onlyActiveContracts() {\r\n        require(contractIndices[msg.sender] != 0);\r\n        _;\r\n    }\r\n\r\n    function Controllable() public Ownable() {\r\n        // The zeroth index of the list of active contracts is occupied by the\r\n        // zero address to ensure that an index of zero can be used to indicate\r\n        // that the contract address is inactive.\r\n        contracts.push(address(0));\r\n    }\r\n\r\n    /**\r\n     * Add a contract address to the list of active contracts.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * _address : address\r\n     *     The contract address to add to the list of active contracts.\r\n     */\r\n    function activateContract(address _address) external onlyOwner {\r\n        require(contractIndices[_address] == 0);\r\n\r\n        contracts.push(_address);\r\n\r\n        // The index of the newly added contract is equal to the length of the\r\n        // array of active contracts minus one, as Solidity is a zero-based\r\n        // language.\r\n        contractIndices[_address] = contracts.length - 1;\r\n    }\r\n\r\n    /**\r\n     * Remove a contract address from the list of active contracts.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * _address : address\r\n     *     The contract address to remove from the list of active contracts.\r\n     */\r\n    function deactivateContract(address _address) external onlyOwner {\r\n        require(contractIndices[_address] != 0);\r\n\r\n        // Get the last contract in the array of active contracts. This address\r\n        // will be used to overwrite the address that will be removed.\r\n        address lastActiveContract = contracts[contracts.length - 1];\r\n\r\n        // Overwrite the address that is to be removed with the value of the\r\n        // last contract in the list. There is a possibility that these are the\r\n        // same values, in which case nothing happens.\r\n        contracts[contractIndices[_address]] = lastActiveContract;\r\n\r\n        // Reduce the contracts array size by one, as the last contract address\r\n        // will have been successfully moved.\r\n        contracts.length--;\r\n\r\n        // Set the address mapping to zero, effectively rendering the contract\r\n        // banned from calling this contract.\r\n        contractIndices[_address] = 0;\r\n    }\r\n\r\n    /**\r\n     * Get the list of active contracts for this contract.\r\n     *\r\n     * Returns\r\n     * -------\r\n     * address[]\r\n     *     The list of contract addresses that are allowed to call the\r\n     *     contract-restricted methods of this contract.\r\n     */\r\n    function getActiveContracts() external view returns (address[]) {\r\n        return contracts;\r\n    }\r\n}\r\n\r\nlibrary Tools {\r\n    /**\r\n     * Concatenate two strings.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * stringLeft : string\r\n     *     A string to concatenate with another string. This is the left part.\r\n     * stringRight : string\r\n     *     A string to concatenate with another string. This is the right part.\r\n     *\r\n     * Returns\r\n     * -------\r\n     * string\r\n     *     The resulting string from concatenating the two given strings.\r\n     */\r\n    function concatenate(\r\n        string stringLeft,\r\n        string stringRight\r\n    )\r\n        internal\r\n        pure\r\n        returns (string)\r\n    {\r\n        // Get byte representations of both strings to allow for one-by-one\r\n        // character iteration.\r\n        bytes memory stringLeftBytes = bytes(stringLeft);\r\n        bytes memory stringRightBytes = bytes(stringRight);\r\n\r\n        // Initialize new string holder with the appropriate number of bytes to\r\n        // hold the concatenated string.\r\n        string memory resultString = new string(\r\n            stringLeftBytes.length + stringRightBytes.length\r\n        );\r\n\r\n        // Get a bytes representation of the result string to allow for direct\r\n        // modification.\r\n        bytes memory resultBytes = bytes(resultString);\r\n\r\n        // Initialize a number to hold the current index of the result string\r\n        // to assign a character to.\r\n        uint k = 0;\r\n\r\n        // First loop over the left string, and afterwards over the right\r\n        // string to assign each character to its proper location in the new\r\n        // string.\r\n        for (uint i = 0; i < stringLeftBytes.length; i++) {\r\n            resultBytes[k++] = stringLeftBytes[i];\r\n        }\r\n\r\n        for (i = 0; i < stringRightBytes.length; i++) {\r\n            resultBytes[k++] = stringRightBytes[i];\r\n        }\r\n\r\n        return string(resultBytes);\r\n    }\r\n\r\n    /**\r\n     * Convert 256-bit unsigned integer into a 32 bytes structure.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * value : uint256\r\n     *     The unsigned integer to convert to bytes32.\r\n     *\r\n     * Returns\r\n     * -------\r\n     * bytes32\r\n     *     The bytes32 representation of the given unsigned integer.\r\n     */\r\n    function uint256ToBytes32(uint256 value) internal pure returns (bytes32) {\r\n        if (value == 0) {\r\n            return '0';\r\n        }\r\n\r\n        bytes32 resultBytes;\r\n\r\n        while (value > 0) {\r\n            resultBytes = bytes32(uint(resultBytes) / (2 ** 8));\r\n            resultBytes |= bytes32(((value % 10) + 48) * 2 ** (8 * 31));\r\n            value /= 10;\r\n        }\r\n\r\n        return resultBytes;\r\n    }\r\n\r\n    /**\r\n     * Convert bytes32 data structure into a string.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * data : bytes32\r\n     *     The bytes to convert to a string.\r\n     *\r\n     * Returns\r\n     * -------\r\n     * string\r\n     *     The string representation of given bytes.\r\n     *\r\n     * Notes\r\n     * -----\r\n     * This method is right-padded with zero bytes.\r\n     */\r\n    function bytes32ToString(bytes32 data) internal pure returns (string) {\r\n        bytes memory bytesString = new bytes(32);\r\n\r\n        for (uint i = 0; i < 32; i++) {\r\n            bytes1 char = bytes1(bytes32(uint256(data) * 2 ** (8 * i)));\r\n\r\n            if (char != 0) {\r\n                bytesString[i] = char;\r\n            }\r\n        }\r\n\r\n        return string(bytesString);\r\n    }\r\n}\r\n\r\n/**\r\n * Partial interface of former ownership contract.\r\n *\r\n * This interface is used to perform the migration of tokens, from the former\r\n * ownership contract to the current version. The inclusion of the entire\r\n * contract is too bulky, hence the partial interface.\r\n */\r\ninterface PartialOwnership {\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n    function totalSupply() external view returns (uint256);\r\n}\r\n\r\n/**\r\n * Ethergotchi Ownership Contract\r\n *\r\n * This contract governs the \"non-fungible tokens\" (NFTs) that represent the\r\n * various Ethergotchi owned by players within Aethia.\r\n *\r\n * The NFTs are implemented according to the standard described in EIP-721 as\r\n * it was on March 19th, 2018.\r\n *\r\n * In addition to the mentioned specification, a method was added to create new\r\n * tokens: `add(uint256 _tokenId, address _owner)`. This method can *only* be\r\n * called by activated Aethia game contracts.\r\n *\r\n * For more information on Aethia and/or Ethergotchi, visit the following\r\n * website: https://aethia.co\r\n */\r\ncontract EthergotchiOwnershipV2 is\r\n    Controllable,\r\n    ERC721,\r\n    ERC721Enumerable,\r\n    ERC721Metadata\r\n{\r\n    // Direct mapping to keep track of token owners.\r\n    mapping(uint256 => address) private ownerByTokenId;\r\n\r\n    // Mapping that keeps track of all tokens owned by a specific address. This\r\n    // allows for iteration by owner, and is implemented to be able to comply\r\n    // with the enumeration methods described in the ERC721Enumerable interface.\r\n    mapping(address => uint256[]) private tokenIdsByOwner;\r\n\r\n    // Mapping that keeps track of a token\"s position in an owner\"s list of\r\n    // tokens. This allows for constant time look-ups within the list, instead\r\n    // of needing to iterate the list of tokens.\r\n    mapping(uint256 => uint256) private ownerTokenIndexByTokenId;\r\n\r\n    // Mapping that keeps track of addresses that are approved to make a\r\n    // transfer of a token. Approval can only be given to a single address, but\r\n    // can be overridden for modification or retraction purposes.\r\n    mapping(uint256 => address) private approvedTransfers;\r\n\r\n    // Mapping that keeps track of operators that are allowed to perform\r\n    // actions on behalf of another address. An address is allowed to set more\r\n    // than one operator. Operators can perform all actions on behalf on an\r\n    // address, *except* for setting a different operator.\r\n    mapping(address => mapping(address => bool)) private operators;\r\n\r\n    // Total number of tokens governed by this contract. This allows for the\r\n    // enumeration of all tokens, provided that tokens are created with their\r\n    // identifiers being numbers, incremented by one.\r\n    uint256 private totalTokens;\r\n\r\n    // The ERC-165 identifier of the ERC-165 interface. This contract\r\n    // implements the `supportsInterface` method to check whether other types\r\n    // of standard interfaces are supported.\r\n    bytes4 private constant INTERFACE_SIGNATURE_ERC165 = bytes4(\r\n        keccak256(\"supportsInterface(bytes4)\")\r\n    );\r\n\r\n    // The ERC-165 identifier of the ERC-721 interface. This contract\r\n    // implements all methods of the ERC-721 Enumerable interface, and uses\r\n    // this identifier to supply the correct answer to a call to\r\n    // `supportsInterface`.\r\n    bytes4 private constant INTERFACE_SIGNATURE_ERC721 = bytes4(\r\n        keccak256(\"balanceOf(address)\") ^\r\n        keccak256(\"ownerOf(uint256)\") ^\r\n        keccak256(\"safeTransferFrom(address,address,uint256,bytes)\") ^\r\n        keccak256(\"safeTransferFrom(address,address,uint256)\") ^\r\n        keccak256(\"transferFrom(address,address,uint256)\") ^\r\n        keccak256(\"approve(address,uint256)\") ^\r\n        keccak256(\"setApprovalForAll(address,bool)\") ^\r\n        keccak256(\"getApproved(uint256)\") ^\r\n        keccak256(\"isApprovedForAll(address,address)\")\r\n    );\r\n\r\n    // The ERC-165 identifier of the ERC-721 Enumerable interface. This\r\n    // contract implements all methods of the ERC-721 Enumerable interface, and\r\n    // uses this identifier to supply the correct answer to a call to\r\n    // `supportsInterface`.\r\n    bytes4 private constant INTERFACE_SIGNATURE_ERC721_ENUMERABLE = bytes4(\r\n        keccak256(\"totalSupply()\") ^\r\n        keccak256(\"tokenByIndex(uint256)\") ^\r\n        keccak256(\"tokenOfOwnerByIndex(address,uint256)\")\r\n    );\r\n\r\n    // The ERC-165 identifier of the ERC-721 Metadata interface. This contract\r\n    // implements all methods of the ERC-721 Metadata interface, and uses the\r\n    // identifier to supply the correct answer to a `supportsInterface` call.\r\n    bytes4 private constant INTERFACE_SIGNATURE_ERC721_METADATA = bytes4(\r\n        keccak256(\"name()\") ^\r\n        keccak256(\"symbol()\") ^\r\n        keccak256(\"tokenURI(uint256)\")\r\n    );\r\n\r\n    // The ERC-165 identifier of the ERC-721 Token Receiver interface. This\r\n    // is not implemented by this contract, but is used to identify the\r\n    // response given by the receiving contracts, if the `safeTransferFrom`\r\n    // method is used.\r\n    bytes4 private constant INTERFACE_SIGNATURE_ERC721_TOKEN_RECEIVER = bytes4(\r\n        keccak256(\"onERC721Received(address,uint256,bytes)\")\r\n    );\r\n\r\n    event Transfer(\r\n        address indexed _from,\r\n        address indexed _to,\r\n        uint256 _tokenId\r\n    );\r\n\r\n    event Approval(\r\n        address indexed _owner,\r\n        address indexed _approved,\r\n        uint256 _tokenId\r\n    );\r\n\r\n    event ApprovalForAll(\r\n        address indexed _owner,\r\n        address indexed _operator,\r\n        bool _approved\r\n    );\r\n\r\n    /**\r\n     * Modify method to only allow calls if the token is valid.\r\n     *\r\n     * Notice\r\n     * ------\r\n     * Ethergotchi are valid if they are owned by an address that is not the\r\n     * zero address.\r\n     */\r\n    modifier onlyValidToken(uint256 _tokenId) {\r\n        require(ownerByTokenId[_tokenId] != address(0));\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Modify method to only allow transfers from authorized callers.\r\n     *\r\n     * Notice\r\n     * ------\r\n     * This method also adds a few checks against common transfer beneficiary\r\n     * mistakes to prevent a subset of unintended transfers that cannot be\r\n     * reverted.\r\n     */\r\n    modifier onlyValidTransfers(address _from, address _to, uint256 _tokenId) {\r\n        // Get owner of the token. This is used to check against various cases\r\n        // where the caller is allowed to transfer the token.\r\n        address tokenOwner = ownerByTokenId[_tokenId];\r\n\r\n        // Check whether the caller is allowed to transfer the token with given\r\n        // identifier. The caller is allowed to perform the transfer in any of\r\n        // the following cases:\r\n        //  1. the caller is the owner of the token;\r\n        //  2. the caller is approved by the owner of the token to transfer\r\n        //     that specific token; or\r\n        //  3. the caller is approved as operator by the owner of the token, in\r\n        //     which case the caller is approved to perform any action on\r\n        //     behalf of the owner.\r\n        require(\r\n            msg.sender == tokenOwner ||\r\n            msg.sender == approvedTransfers[_tokenId] ||\r\n            operators[tokenOwner][msg.sender]\r\n        );\r\n\r\n        // Check against accidental transfers to the common \"wrong\" addresses.\r\n        // This includes the zero address, this ownership contract address, and\r\n        // \"non-transfers\" where the same address is filled in for both `_from`\r\n        // and `_to`.\r\n        require(\r\n            _to != address(0) &&\r\n            _to != address(this) &&\r\n            _to != _from\r\n        );\r\n\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Ethergotchi ownership contract constructor\r\n     *\r\n     * At the time of contract construction, an Ethergotchi is artificially\r\n     * constructed to ensure that Ethergotchi are numbered starting from one.\r\n     */\r\n    function EthergotchiOwnershipV2(\r\n        address _formerContract\r\n    )\r\n        public\r\n        Controllable()\r\n    {\r\n        ownerByTokenId[0] = address(0);\r\n        tokenIdsByOwner[address(0)].push(0);\r\n        ownerTokenIndexByTokenId[0] = 0;\r\n\r\n        // The migration index is initialized to 1 as the zeroth token need not\r\n        // be migrated; it is already created during the construction of this\r\n        // contract.\r\n        migrationIndex = 1;\r\n        formerContract = PartialOwnership(_formerContract);\r\n    }\r\n\r\n    /**\r\n     * Add new token into circulation.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * _tokenId : uint256\r\n     *     The identifier of the token to add into circulation.\r\n     * _owner : address\r\n     *     The address of the owner who receives the newly added token.\r\n     *\r\n     * Notice\r\n     * ------\r\n     * This method can only be called by active game contracts. Game contracts\r\n     * are added and modified manually. These additions and modifications\r\n     * always trigger an event for audit purposes.\r\n     */\r\n    function add(\r\n        uint256 _tokenId,\r\n        address _owner\r\n    )\r\n        external\r\n        onlyActiveContracts\r\n    {\r\n        // Safety checks to prevent contracts from calling this method without\r\n        // setting the proper arguments.\r\n        require(_tokenId != 0 && _owner != address(0));\r\n\r\n        _add(_tokenId, _owner);\r\n\r\n        // As per the standard, transfers of newly created tokens should always\r\n        // originate from the zero address.\r\n        Transfer(address(0), _owner, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * Check whether contract supports given interface.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * interfaceID : bytes4\r\n     *     The four-bytes representation of an interface of which to check\r\n     *     whether this contract supports it.\r\n     *\r\n     * Returns\r\n     * -------\r\n     * bool\r\n     *     True if given interface is supported, else False.\r\n     *\r\n     * Notice\r\n     * ------\r\n     * It is expected that the `bytes4` values of interfaces are generated by\r\n     * calling XOR on all function signatures of the interface.\r\n     *\r\n     * Technically more interfaces are supported, as some interfaces may be\r\n     * subsets of the supported interfaces. This check is only to be used to\r\n     * verify whether \"standard interfaces\" are supported.\r\n     */\r\n    function supportsInterface(\r\n        bytes4 interfaceID\r\n    )\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        return (\r\n            interfaceID == INTERFACE_SIGNATURE_ERC165 ||\r\n            interfaceID == INTERFACE_SIGNATURE_ERC721 ||\r\n            interfaceID == INTERFACE_SIGNATURE_ERC721_METADATA ||\r\n            interfaceID == INTERFACE_SIGNATURE_ERC721_ENUMERABLE\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get the name of the token this contract governs ownership of.\r\n     *\r\n     * Notice\r\n     * ------\r\n     * This is the collective name of the token. Individual tokens may be named\r\n     * differently by their owners.\r\n     */\r\n    function name() external pure returns (string) {\r\n        return \"Ethergotchi\";\r\n    }\r\n\r\n    /**\r\n     * Get the symbol of the token this contract governs ownership of.\r\n     *\r\n     * Notice\r\n     * ------\r\n     * This symbol has been explicitly changed to `ETHERGOTCHI` from `GOTCHI`\r\n     * in the `PHOENIX` patch of Aethia to prevent confusion with older tokens.\r\n     */\r\n    function symbol() external pure returns (string) {\r\n        return \"ETHERGOTCHI\";\r\n    }\r\n\r\n    /**\r\n     * Get the URI pointing to a JSON file with metadata for a given token.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * _tokenId : uint256\r\n     *     The identifier of the token to get the URI for.\r\n     *\r\n     * Returns\r\n     * -------\r\n     * string\r\n     *     The URI pointing to a JSON file with metadata for the token with\r\n     *     given identifier.\r\n     *\r\n     * Notice\r\n     * ------\r\n     * This method returns a string that may contain more than one null-byte,\r\n     * because the conversion method is not ideal.\r\n     */\r\n    function tokenURI(uint256 _tokenId) external view returns (string) {\r\n        bytes32 tokenIdBytes = Tools.uint256ToBytes32(_tokenId);\r\n\r\n        return Tools.concatenate(\r\n            \"https://aethia.co/ethergotchi/\",\r\n            Tools.bytes32ToString(tokenIdBytes)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get the number of tokens assigned to given owner.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * _owner : address\r\n     *     The address of the owner of which to get the number of owned tokens\r\n     *     of.\r\n     *\r\n     * Returns\r\n     * -------\r\n     * uint256\r\n     *     The number of tokens owned by given owner.\r\n     *\r\n     * Notice\r\n     * ------\r\n     * Tokens owned by the zero address are considered invalid, as described in\r\n     * the EIP 721 standard, and queries regarding the zero address will result\r\n     * in the transaction being rejected.\r\n     */\r\n    function balanceOf(address _owner) external view returns (uint256) {\r\n        require(_owner != address(0));\r\n\r\n        return tokenIdsByOwner[_owner].length;\r\n    }\r\n\r\n    /**\r\n     * Get the address of the owner of given token.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * _tokenId : uint256\r\n     *     The identifier of the token of which to get the owner\"s address.\r\n     *\r\n     * Returns\r\n     * -------\r\n     * address\r\n     *     The address of the owner of given token.\r\n     *\r\n     * Notice\r\n     * ------\r\n     * Tokens owned by the zero address are considered invalid, as described in\r\n     * the EIP 721 standard, and queries regarding the zero address will result\r\n     * in the transaction being rejected.\r\n     */\r\n    function ownerOf(uint256 _tokenId) external view returns (address) {\r\n        // Store the owner in a temporary variable to avoid having to do the\r\n        // lookup twice.\r\n        address _owner = ownerByTokenId[_tokenId];\r\n\r\n        require(_owner != address(0));\r\n\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * Transfer the ownership of given token from one address to another.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * _from : address\r\n     *     The benefactor address to transfer the given token from.\r\n     * _to : address\r\n     *     The beneficiary address to transfer the given token to.\r\n     * _tokenId : uint256\r\n     *     The identifier of the token to transfer.\r\n     * data : bytes\r\n     *     Non-specified data to send along the transfer towards the `to`\r\n     *     address that can be processed.\r\n     *\r\n     * Notice\r\n     * ------\r\n     * This method performs a check to determine whether the receiving party is\r\n     * a smart contract by calling the `_isContract` method. This works until\r\n     * the `Serenity` update of Ethereum is deployed.\r\n     */\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId,\r\n        bytes data\r\n    )\r\n        external\r\n        onlyValidToken(_tokenId)\r\n    {\r\n        // Call the internal `_safeTransferFrom` method to avoid duplicating\r\n        // the transfer code.\r\n        _safeTransferFrom(_from, _to, _tokenId, data);\r\n    }\r\n\r\n    /**\r\n     * Transfer the ownership of given token from one address to another.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * _from : address\r\n     *     The benefactor address to transfer the given token from.\r\n     * _to : address\r\n     *     The beneficiary address to transfer the given token to.\r\n     * _tokenId : uint256\r\n     *     The identifier of the token to transfer.\r\n     *\r\n     * Notice\r\n     * ------\r\n     * This method does exactly the same as calling the `safeTransferFrom`\r\n     * method with the `data` parameter set to an empty bytes value:\r\n     *  `safeTransferFrom(_from, _to, _tokenId, \"\")`\r\n     */\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    )\r\n        external\r\n        onlyValidToken(_tokenId)\r\n    {\r\n        // Call the internal `_safeTransferFrom` method to avoid duplicating\r\n        // the transfer code.\r\n        _safeTransferFrom(_from, _to, _tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * Transfer the ownership of given token from one address to another.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * _from : address\r\n     *     The benefactor address to transfer the given token from.\r\n     * _to : address\r\n     *     The beneficiary address to transfer the given token to.\r\n     * _tokenId : uint256\r\n     *     The identifier of the token to transfer.\r\n     *\r\n     * Notice\r\n     * ------\r\n     * This method performs a few rudimentary checks to determine whether the\r\n     * receiving party can actually receive the token. However, it is still up\r\n     * to the caller to ensure this is actually the case.\r\n     */\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    )\r\n        external\r\n        onlyValidToken(_tokenId)\r\n        onlyValidTransfers(_from, _to, _tokenId)\r\n    {\r\n        _transfer(_to, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * Approve the given address for the transfer of the given token.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * _approved : address\r\n     *     The address to approve. Approval allows the address to transfer the\r\n     *     given token to a different address.\r\n     * _tokenId : uint256\r\n     *     The identifier of the token to give transfer approval for.\r\n     *\r\n     * Notice\r\n     * ------\r\n     * There is no specific method to revoke approvals, but the approval is\r\n     * removed after the transfer has been completed. Additionally the owner\r\n     * or operator may call the method with the zero address as `_approved` to\r\n     * effectively revoke the approval.\r\n     */\r\n    function approve(address _approved, uint256 _tokenId) external {\r\n        address _owner = ownerByTokenId[_tokenId];\r\n\r\n        // Approval can only be given by the owner or an operator approved by\r\n        // the owner.\r\n        require(msg.sender == _owner || operators[_owner][msg.sender]);\r\n\r\n        // Set address as approved for transfer. It can be the case that the\r\n        // address was already set (e.g. this method was called twice in a row)\r\n        // in which case this does not change anything.\r\n        approvedTransfers[_tokenId] = _approved;\r\n\r\n        Approval(msg.sender, _approved, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * Set approval for a third-party to manage all tokens of the caller.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * _operator : address\r\n     *     The address to set the operator status for.\r\n     * _approved : bool\r\n     *     The operator status. True if the given address should be allowed to\r\n     *     act on behalf of the caller, else False.\r\n     *\r\n     * Notice\r\n     * ------\r\n     * There is no duplicate checking done out of simplicity. Callers are thus\r\n     * able to set the same address as operator a multitude of times, even if\r\n     * it does not change the actual state of the system.\r\n     */\r\n    function setApprovalForAll(address _operator, bool _approved) external {\r\n        operators[msg.sender][_operator] = _approved;\r\n\r\n        ApprovalForAll(msg.sender, _operator, _approved);\r\n    }\r\n\r\n    /**\r\n     * Get approved address for given token.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * _tokenId : uint256\r\n     *     The identifier of the token of which to get the approved address of.\r\n     *\r\n     * Returns\r\n     * -------\r\n     * address\r\n     *     The address that is allowed to initiate a transfer of the given\r\n     *     token.\r\n     *\r\n     * Notice\r\n     * ------\r\n     * Technically this method could be implemented without the method modifier\r\n     * as the network guarantees that the address mapping is initiated with all\r\n     * addresses set to the zero address. The requirement is implemented to\r\n     * comply with the standard as described in EIP-721.\r\n     */\r\n    function getApproved(\r\n        uint256 _tokenId\r\n    )\r\n        external\r\n        view\r\n        onlyValidToken(_tokenId)\r\n        returns (address)\r\n    {\r\n        return approvedTransfers[_tokenId];\r\n    }\r\n\r\n    /**\r\n     * Check whether an address is an authorized operator of another address.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * _owner : address\r\n     *     The address of which to check whether it has approved the other\r\n     *     address to act as operator.\r\n     * _operator : address\r\n     *     The address of which to check whether it has been approved to act\r\n     *     as operator on behalf of `_owner`.\r\n     *\r\n     * Returns\r\n     * -------\r\n     * bool\r\n     *     True if `_operator` is approved for all actions on behalf of\r\n     *     `_owner`.\r\n     *\r\n     * Notice\r\n     * ------\r\n     * This method cannot fail, as the Ethereum network guarantees that all\r\n     * address mappings exist and are set to the zero address by default.\r\n     */\r\n    function isApprovedForAll(\r\n        address _owner,\r\n        address _operator\r\n    )\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        return operators[_owner][_operator];\r\n    }\r\n\r\n    /**\r\n     * Get the total number of tokens currently in circulation.\r\n     *\r\n     * Returns\r\n     * -------\r\n     * uint256\r\n     *     The total number of tokens currently in circulation.\r\n     */\r\n    function totalSupply() external view returns (uint256) {\r\n        return totalTokens;\r\n    }\r\n\r\n    /**\r\n     * Get token identifier by index.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * _index : uint256\r\n     *     The index of the token to get the identifier of.\r\n     *\r\n     * Returns\r\n     * -------\r\n     * uint256\r\n     *     The identifier of the token at given index.\r\n     *\r\n     * Notice\r\n     * ------\r\n     * Ethergotchi tokens are incrementally numbered starting from zero, and\r\n     * always go up by one. The index of the token is thus equivalent to its\r\n     * identifier.\r\n     */\r\n    function tokenByIndex(uint256 _index) external view returns (uint256) {\r\n        require(_index < totalTokens);\r\n\r\n        return _index;\r\n    }\r\n\r\n    /**\r\n     * Get token of owner by index.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * _owner : address\r\n     *     The address of the owner of which to get the token of.\r\n     * _index : uint256\r\n     *     The index of the token in the given owner\"s list of token.\r\n     *\r\n     * Returns\r\n     * -------\r\n     * uint256\r\n     *     The identifier of the token at given index of an owner\"s list of\r\n     *     tokens.\r\n     */\r\n    function tokenOfOwnerByIndex(\r\n        address _owner,\r\n        uint256 _index\r\n    )\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        require(_index < tokenIdsByOwner[_owner].length);\r\n\r\n        return tokenIdsByOwner[_owner][_index];\r\n    }\r\n\r\n    /**\r\n     * Check whether given address is a smart contract.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * _address : address\r\n     *     The address of which to check whether it is a contract.\r\n     *\r\n     * Returns\r\n     * -------\r\n     * bool\r\n     *     True if given address is a contract, else False.\r\n     *\r\n     * Notice\r\n     * ------\r\n     * This method works as long as the `Serenity` update of Ethereum has not\r\n     * been deployed. At the time of writing, contracts cannot set their code\r\n     * size to zero, nor can \"normal\" addresses set their code size to anything\r\n     * non-zero. With `Serenity` the idea will be that each and every address\r\n     * is an contract, effectively rendering this method.\r\n     */\r\n    function _isContract(address _address) internal view returns (bool) {\r\n        uint size;\r\n\r\n        assembly {\r\n            size := extcodesize(_address)\r\n        }\r\n\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * Transfer the ownership of given token from one address to another.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * _from : address\r\n     *     The benefactor address to transfer the given token from.\r\n     * _to : address\r\n     *     The beneficiary address to transfer the given token to.\r\n     * _tokenId : uint256\r\n     *     The identifier of the token to transfer.\r\n     * data : bytes\r\n     *     Non-specified data to send along the transfer towards the `to`\r\n     *     address that can be processed.\r\n     *\r\n     * Notice\r\n     * ------\r\n     * This method performs a check to determine whether the receiving party is\r\n     * a smart contract by calling the `_isContract` method. This works until\r\n     * the `Serenity` update of Ethereum is deployed.\r\n     */\r\n    function _safeTransferFrom(\r\n        address _from, \r\n        address _to, \r\n        uint256 _tokenId,\r\n        bytes data\r\n    )\r\n        internal\r\n        onlyValidTransfers(_from, _to, _tokenId)\r\n    {\r\n        // Call the method that performs the actual transfer. All common cases\r\n        // of \"wrong\" transfers have already been checked at this point. The\r\n        // internal transfer method does no checking.\r\n        _transfer(_to, _tokenId);\r\n\r\n        // Check whether the receiving party is a contract, and if so, call\r\n        // the `onERC721Received` method as defined in the ERC-721 standard.\r\n        if (_isContract(_to)) {\r\n\r\n            // Assume the receiving party has implemented ERC721TokenReceiver,\r\n            // as otherwise the \"unsafe\" `transferFrom` method should have been\r\n            // called instead.\r\n            ERC721TokenReceiver _receiver = ERC721TokenReceiver(_to);\r\n\r\n            // The response returned by `onERC721Received` of the receiving\r\n            // contract\"s `on *must* be equal to the magic number defined by\r\n            // the ERC-165 signature of `ERC721TokenReceiver`. If this is not\r\n            // the case, the transaction will be reverted.\r\n            require(\r\n                _receiver.onERC721Received(\r\n                    address(this),\r\n                    _tokenId,\r\n                    data\r\n                ) == INTERFACE_SIGNATURE_ERC721_TOKEN_RECEIVER\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Transfer token to new owner.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * _to : address\r\n     *     The address of the owner-to-be of given token.\r\n     * _tokenId : _tokenId\r\n     *     The identifier of the token that is to be transferred.\r\n     *\r\n     * Notice\r\n     * ------\r\n     * This method performs no safety checks as it can only be called within\r\n     * the controlled environment of this contract.\r\n     */\r\n    function _transfer(address _to, uint256 _tokenId) internal {\r\n        // Get current owner of the token. It is technically possible that the\r\n        // owner is the same address as the address to which the token is to be\r\n        // sent to. In this case the token will be moved to the end of the list\r\n        // of tokens owned by this address.\r\n        address _from = ownerByTokenId[_tokenId];\r\n\r\n        // There are two possible scenarios for transfers when it comes to the\r\n        // removal of the token from the side that currently owns the token:\r\n        //  1: the owner has two or more tokens; or\r\n        //  2: the owner has one token.\r\n        if (tokenIdsByOwner[_from].length > 1) {\r\n\r\n            // Get the index of the token that has to be removed from the list\r\n            // of tokens owned by the current owner.\r\n            uint256 tokenIndexToDelete = ownerTokenIndexByTokenId[_tokenId];\r\n\r\n            // To keep the list of tokens without gaps, and thus reducing the\r\n            // gas cost associated with interacting with the list, the last\r\n            // token in the owner\"s list of tokens is moved to fill the gap\r\n            // created by removing the token.\r\n            uint256 tokenIndexToMove = tokenIdsByOwner[_from].length - 1;\r\n\r\n            // Overwrite the token that is to be removed with the token that\r\n            // was at the end of the list. It is possible that both are one and\r\n            // the same, in which case nothing happens.\r\n            tokenIdsByOwner[_from][tokenIndexToDelete] =\r\n                tokenIdsByOwner[_from][tokenIndexToMove];\r\n        }\r\n\r\n        // Remove the last item in the list of tokens owned by the current\r\n        // owner. This item has either already been copied to the location of\r\n        // the token that is to be transferred, or is the only token of this\r\n        // owner in which case the list of tokens owned by this owner is now\r\n        // empty.\r\n        tokenIdsByOwner[_from].length--;\r\n\r\n        // Add the token to the list of tokens owned by `_to`. Items are always\r\n        // added to the very end of the list. This makes the token index of the\r\n        // new token within the owner\"s list of tokens equal to the length of\r\n        // the list minus one as Solidity is a zero-based language. This token\r\n        // index is then set for this token identifier.\r\n        tokenIdsByOwner[_to].push(_tokenId);\r\n        ownerTokenIndexByTokenId[_tokenId] = tokenIdsByOwner[_to].length - 1;\r\n\r\n        // Set the direct ownership information of the token to the new owner\r\n        // after all other ownership-related mappings have been updated to make\r\n        // sure the \"side\" data is correct.\r\n        ownerByTokenId[_tokenId] = _to;\r\n\r\n        // Remove the approved address of this token. It may be the case there\r\n        // was no approved address, in which case nothing changes.\r\n        approvedTransfers[_tokenId] = address(0);\r\n\r\n        // Log the transfer event onto the blockchain to leave behind an audit\r\n        // trail of all transfers that have taken place.\r\n        Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * Add new token into circulation.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * _tokenId : uint256\r\n     *     The identifier of the token to add into circulation.\r\n     * _owner : address\r\n     *     The address of the owner who receives the newly added token.\r\n     */\r\n    function _add(uint256 _tokenId, address _owner) internal {\r\n        // Ensure the token does not already exist, and prevent duplicate calls\r\n        // using the same identifier.\r\n        require(ownerByTokenId[_tokenId] == address(0));\r\n\r\n        // Update the direct ownership mapping, by setting the owner of the\r\n        // token identifier to `_owner`, and adding the token to the list of\r\n        // tokens owned by `_owner`. Arrays are always initialized to empty\r\n        // versions of of their specific type, thus ensuring that the `push`\r\n        // method will not fail.\r\n        ownerByTokenId[_tokenId] = _owner;\r\n        tokenIdsByOwner[_owner].push(_tokenId);\r\n\r\n        // Update the mapping that keeps track of a token\"s index within the\r\n        // list of tokens owned by each owner. At the time of addition a token\r\n        // is always added to the end of the list, and will thus always equal\r\n        // the number of tokens already in the list, minus one, because the\r\n        // arrays within Solidity are zero-based.\r\n        ownerTokenIndexByTokenId[_tokenId] = tokenIdsByOwner[_owner].length - 1;\r\n\r\n        totalTokens += 1;\r\n    }\r\n\r\n    /*********************************************/\r\n    /** MIGRATION state variables and functions **/\r\n    /*********************************************/\r\n\r\n    // This number is used to keep track of how many tokens have been migrated.\r\n    // The number cannot exceed the number of tokens that were assigned to\r\n    // owners in the previous Ownership contract.\r\n    uint256 public migrationIndex;\r\n\r\n    // The previous token ownership contract.\r\n    PartialOwnership private formerContract;\r\n\r\n    /**\r\n     * Migrate data from the former Ethergotchi ownership contract.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * _count : uint256\r\n     *     The number of tokens to migrate in a single transaction.\r\n     *\r\n     * Notice\r\n     * ------\r\n     * This method is limited in use to ensure no 'malicious' calls are made.\r\n     * Additionally, this method writes to a contract state variable to keep\r\n     * track of how many tokens have been migrated.\r\n     */\r\n    function migrate(uint256 _count) external onlyOwner {\r\n        // Ensure that the migrate function can *only* be called in a specific\r\n        // time period. This period ranges from Saturday, March 24th, 00:00:00\r\n        // UTC until Sunday, March 25th, 23:59:59 UTC.\r\n        require(1521849600 <= now && now <= 1522022399);\r\n\r\n        // Get the maximum number of tokens handed out by the previous\r\n        // ownership contract.\r\n        uint256 formerTokenCount = formerContract.totalSupply();\r\n\r\n        // The index to stop the migration at for this transaction.\r\n        uint256 endIndex = migrationIndex + _count;\r\n\r\n        // It is possible that the final transaction has a higher end index\r\n        // than there are a number of tokens. In this case, the end index is\r\n        // reduced to ensure no non-existent tokens are migrated.\r\n        if (endIndex >= formerTokenCount) {\r\n            endIndex = formerTokenCount;\r\n        }\r\n\r\n        // Loop through the token identifiers to migrate in this transaction.\r\n        // Token identifiers are equivalent to their 'index', as identifiers\r\n        // start at zero (with the zeroth token being owned by the zero\r\n        // address), and are incremented by one for each new token.\r\n        for (uint256 i = migrationIndex; i < endIndex; i++) {\r\n            address tokenOwner;\r\n\r\n            // There was a malicious account that acquired over 400 eggs via\r\n            // referral codes, which breaks the terms of use. The acquired egg\r\n            // numbers ranged from identifier 1247 up until 1688, excluding\r\n            // 1296, 1297, 1479, 1492, 1550, 1551, and 1555. This was found by\r\n            // looking at activity on the pick-up contract, and tracing it back\r\n            // to the following address:\r\n            //  `0c7a911ac29ea1e3b1d438f98f8bc053131dcaf52`\r\n            if (_isExcluded(i)) {\r\n                tokenOwner = address(0);\r\n            } else {\r\n                tokenOwner = formerContract.ownerOf(i);\r\n            }\r\n\r\n            // Assign the token to the same address that owned it in the\r\n            // previous ownership contract.\r\n            _add(i, tokenOwner);\r\n\r\n            // Log the token transfer. In this case where the token is 'newly'\r\n            // created, but actually transferred from a previous contract, the\r\n            // `_from` address is set to the previous contract address, to\r\n            // signify a migration.\r\n            Transfer(address(formerContract), tokenOwner, i);\r\n        }\r\n\r\n        // Set the new migration index to where the current transaction ended\r\n        // its migration.\r\n        migrationIndex = endIndex;\r\n    }\r\n\r\n    /**\r\n     * Check if Ethergotchi should be excluded from migration.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * _gotchiId : uint256\r\n     *     The identifier of the Ethergotchi of which to check the exclusion\r\n     *     status.\r\n     *\r\n     * Returns\r\n     * -------\r\n     * bool\r\n     *     True if the Ethergotchi should be excluded from the migration, else\r\n     *     False.\r\n     */\r\n    function _isExcluded(uint256 _gotchiId) internal pure returns (bool) {\r\n        return\r\n            1247 <= _gotchiId && _gotchiId <= 1688 &&\r\n            _gotchiId != 1296 &&\r\n            _gotchiId != 1297 &&\r\n            _gotchiId != 1479 &&\r\n            _gotchiId != 1492 &&\r\n            _gotchiId != 1550 &&\r\n            _gotchiId != 1551 &&\r\n            _gotchiId != 1555;\r\n    }\r\n}", "OptimizationUsed": "1", "ContractName": "EthergotchiOwnershipV2", "ByteCode": "0x6060604052600436106101195763ffffffff60e060020a60003504166301ffc9a7811461011e578063022edd351461016a57806306fdde03146101d0578063081812fc1461025a578063095ea7b31461028c57806318160ddd146102b057806323b872dd146102d55780632b8bbbe8146102fd5780632f745c591461031f57806331a765351461034157806342842e0e14610360578063454b0608146103885780634da369131461039e5780634f6ccce7146103b15780636352211e146103c7578063670cec37146103dd57806370a08231146103fc57806395d89b411461041b578063a22cb4651461042e578063a39a45b714610452578063b88d4fde14610471578063c87b56dd146104a8578063e985e9c5146104be575b600080fd5b341561012957600080fd5b6101567fffffffff00000000000000000000000000000000000000000000000000000000600435166104e3565b604051901515815260200160405180910390f35b341561017557600080fd5b61017d610932565b60405160208082528190810183818151815260200191508051906020019060200280838360005b838110156101bc5780820151838201526020016101a4565b505050509050019250505060405180910390f35b34156101db57600080fd5b6101e361099b565b60405160208082528190810183818151815260200191508051906020019080838360005b8381101561021f578082015183820152602001610207565b50505050905090810190601f16801561024c5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b341561026557600080fd5b6102706004356109dc565b604051600160a060020a03909116815260200160405180910390f35b341561029757600080fd5b6102ae600160a060020a0360043516602435610a22565b005b34156102bb57600080fd5b6102c3610af5565b60405190815260200160405180910390f35b34156102e057600080fd5b6102ae600160a060020a0360043581169060243516604435610afb565b341561030857600080fd5b6102ae600435600160a060020a0360243516610c0d565b341561032a57600080fd5b6102c3600160a060020a0360043516602435610ca0565b341561034c57600080fd5b6102ae600160a060020a0360043516610cfc565b341561036b57600080fd5b6102ae600160a060020a0360043581169060243516604435610dee565b341561039357600080fd5b6102ae600435610e33565b34156103a957600080fd5b6102c3610fc8565b34156103bc57600080fd5b6102c3600435610fce565b34156103d257600080fd5b610270600435610fe3565b34156103e857600080fd5b6102ae600160a060020a0360043516611007565b341561040757600080fd5b6102c3600160a060020a03600435166110a8565b341561042657600080fd5b6101e36110db565b341561043957600080fd5b6102ae600160a060020a0360043516602435151561111c565b341561045d57600080fd5b6102ae600160a060020a036004351661118c565b341561047c57600080fd5b6102ae600160a060020a036004803582169160248035909116916044359160643590810191013561120f565b34156104b357600080fd5b6101e3600435611277565b34156104c957600080fd5b610156600160a060020a03600435811690602435166112d8565b60006040517f737570706f727473496e7465726661636528627974657334290000000000000081526019016040518091039020600160e060020a03191682600160e060020a03191614806107a257506040517f6973417070726f766564466f72416c6c28616464726573732c6164647265737381527f2900000000000000000000000000000000000000000000000000000000000000602082015260210160405180910390206040517f676574417070726f7665642875696e7432353629000000000000000000000000815260140160405180910390206040517f736574417070726f76616c466f72416c6c28616464726573732c626f6f6c29008152601f0160405180910390206040517f617070726f766528616464726573732c75696e74323536290000000000000000815260180160405180910390206040517f7472616e7366657246726f6d28616464726573732c616464726573732c75696e81527f7432353629000000000000000000000000000000000000000000000000000000602082015260250160405180910390206040517f736166655472616e7366657246726f6d28616464726573732c6164647265737381527f2c75696e74323536290000000000000000000000000000000000000000000000602082015260290160405180910390206040517f736166655472616e7366657246726f6d28616464726573732c6164647265737381527f2c75696e743235362c62797465732900000000000000000000000000000000006020820152602f0160405180910390206040517f6f776e65724f662875696e743235362900000000000000000000000000000000815260100160405180910390206040517f62616c616e63654f662861646472657373290000000000000000000000000000815260120160405180910390201818181818181818600160e060020a03191682600160e060020a031916145b8061085457506040517f746f6b656e5552492875696e7432353629000000000000000000000000000000815260110160405180910390206040517f73796d626f6c2829000000000000000000000000000000000000000000000000815260080160405180910390206040517f6e616d6528290000000000000000000000000000000000000000000000000000815260060160405180910390201818600160e060020a03191682600160e060020a031916145b8061092c57506040517f746f6b656e4f664f776e65724279496e64657828616464726573732c75696e7481527f3235362900000000000000000000000000000000000000000000000000000000602082015260240160405180910390206040517f746f6b656e4279496e6465782875696e74323536290000000000000000000000815260150160405180910390206040517f746f74616c537570706c792829000000000000000000000000000000000000008152600d0160405180910390201818600160e060020a03191682600160e060020a031916145b92915050565b61093a611acc565b600280548060200260200160405190810160405280929190818152602001828054801561099057602002820191906000526020600020905b8154600160a060020a03168152600190910190602001808311610972575b505050505090505b90565b6109a3611acc565b60408051908101604052600b81527f4574686572676f746368690000000000000000000000000000000000000000006020820152905090565b6000818152600360205260408120548290600160a060020a03161515610a0157600080fd5b600083815260066020526040902054600160a060020a031691505b50919050565b600081815260036020526040902054600160a060020a03908116903316811480610a725750600160a060020a038082166000908152600760209081526040808320339094168352929052205460ff165b1515610a7d57600080fd5b60008281526006602052604090819020805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a038681169182179092559133909116907f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b9259085905190815260200160405180910390a3505050565b60085490565b6000818152600360205260409020548190600160a060020a03161515610b2057600080fd5b600082815260036020526040902054849084908490600160a060020a03908116903316811480610b6a575060008281526006602052604090205433600160a060020a039081169116145b80610b9b5750600160a060020a038082166000908152600760209081526040808320339094168352929052205460ff165b1515610ba657600080fd5b600160a060020a03831615801590610bd0575030600160a060020a031683600160a060020a031614155b8015610bee575083600160a060020a031683600160a060020a031614155b1515610bf957600080fd5b610c038787611306565b5050505050505050565b600160a060020a0333166000908152600160205260409020541515610c3157600080fd5b8115801590610c485750600160a060020a03811615155b1515610c5357600080fd5b610c5d82826114b8565b600160a060020a03811660007fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef8460405190815260200160405180910390a35050565b600160a060020a0382166000908152600460205260408120548210610cc457600080fd5b600160a060020a0383166000908152600460205260409020805483908110610ce857fe5b906000526020600020900154905092915050565b6000805433600160a060020a03908116911614610d1857600080fd5b600160a060020a0382166000908152600160205260409020541515610d3c57600080fd5b600280546000198101908110610d4e57fe5b6000918252602080832090910154600160a060020a0385811684526001909252604090922054600280549290931693508392918110610d8957fe5b6000918252602090912001805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a03929092169190911790556002805490610dd2906000198301611ade565b5050600160a060020a0316600090815260016020526040812055565b6000818152600360205260409020548190600160a060020a03161515610e1357600080fd5b610e2d848484602060405190810160405260008152611572565b50505050565b6000805481908190819033600160a060020a03908116911614610e5557600080fd5b42635ab5950011158015610e6d5750635ab837ff4211155b1515610e7857600080fd5b600a54600160a060020a03166318160ddd6040518163ffffffff1660e060020a028152600401602060405180830381600087803b1515610eb757600080fd5b5af11515610ec457600080fd5b50505060405180516009549095508601935050838310610ee2578392505b60095491505b82821015610fbf57610ef9826117cb565b15610f0657506000610f67565b600a54600160a060020a0316636352211e8360405160e060020a63ffffffff84160281526004810191909152602401602060405180830381600087803b1515610f4e57600080fd5b5af11515610f5b57600080fd5b50505060405180519150505b610f7182826114b8565b600a54600160a060020a0380831691167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef8460405190815260200160405180910390a3600190910190610ee8565b50506009555050565b60095481565b6008546000908210610fdf57600080fd5b5090565b600081815260036020526040812054600160a060020a031680151561092c57600080fd5b60005433600160a060020a0390811691161461102257600080fd5b600160a060020a0381166000908152600160205260409020541561104557600080fd5b60028054600181016110578382611ade565b5060009182526020808320919091018054600160a060020a0390941673ffffffffffffffffffffffffffffffffffffffff199094168417905560025492825260019052604090206000199091019055565b6000600160a060020a03821615156110bf57600080fd5b50600160a060020a031660009081526004602052604090205490565b6110e3611acc565b60408051908101604052600b81527f4554484552474f544348490000000000000000000000000000000000000000006020820152905090565b33600160a060020a0390811660008181526007602090815260408083209487168084529490915290819020805460ff19168515151790557f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c3190849051901515815260200160405180910390a35050565b60005433600160a060020a039081169116146111a757600080fd5b6000805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0383161790557ffd652a3e403c519f3c9774cf5ab315aa0dca9f23b34252c4691360c4df3d60c781604051600160a060020a03909116815260200160405180910390a150565b6000838152600360205260409020548390600160a060020a0316151561123457600080fd5b61126f86868686868080601f016020809104026020016040519081016040528181529291906020840183838082843750611572945050505050565b505050505050565b61127f611acc565b600061128a83611845565b90506112d160408051908101604052601e81527f68747470733a2f2f6165746869612e636f2f6574686572676f746368692f000060208201526112cc836118a0565b61196b565b9392505050565b600160a060020a03918216600090815260076020908152604080832093909416825291909152205460ff1690565b600081815260036020908152604080832054600160a060020a03168084526004909252822054909190819060019011156113b2575050600082815260056020908152604080832054600160a060020a038516845260049092529091208054600019810191908290811061137557fe5b6000918252602080832090910154600160a060020a0386168352600490915260409091208054849081106113a557fe5b6000918252602090912001555b600160a060020a03831660009081526004602052604090208054906113db906000198301611ade565b50600160a060020a03851660009081526004602052604090208054600181016114048382611ade565b506000918252602080832091909101869055600160a060020a038088168084526004835260408085205489865260058552818620600019909101905560038452808520805473ffffffffffffffffffffffffffffffffffffffff19908116841790915560069094529384902080549093169092559091908516907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef9087905190815260200160405180910390a35050505050565b600082815260036020526040902054600160a060020a0316156114da57600080fd5b6000828152600360209081526040808320805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a03861690811790915583526004909152902080546001810161152d8382611ade565b506000918252602080832091909101849055600160a060020a039092168152600482526040808220549382526005909252206000199091019055600880546001019055565b600082815260036020526040812054859085908590600160a060020a039081169033168114806115bc575060008281526006602052604090205433600160a060020a039081169116145b806115ed5750600160a060020a038082166000908152600760209081526040808320339094168352929052205460ff165b15156115f857600080fd5b600160a060020a03831615801590611622575030600160a060020a031683600160a060020a031614155b8015611640575083600160a060020a031683600160a060020a031614155b151561164b57600080fd5b6116558888611306565b61165e88611ac4565b156117c0578794506040517f6f6e455243373231526563656976656428616464726573732c75696e7432353681527f2c6279746573290000000000000000000000000000000000000000000000000060208201526027016040518091039020600160e060020a03191685600160a060020a031663f0b9e5ba308a8a6040518463ffffffff1660e060020a0281526004018084600160a060020a0316600160a060020a0316815260200183815260200180602001828103825283818151815260200191508051906020019080838360005b8381101561174657808201518382015260200161172e565b50505050905090810190601f1680156117735780820380516001836020036101000a031916815260200191505b50945050505050602060405180830381600087803b151561179357600080fd5b5af115156117a057600080fd5b50505060405180519050600160e060020a0319161415156117c057600080fd5b505050505050505050565b6000816104df111580156117e157506106988211155b80156117ef57508161051014155b80156117fd57508161051114155b801561180b5750816105c714155b80156118195750816105d414155b801561182757508161060e14155b801561183557508161060f14155b801561092c575050610613141590565b600080821515611877577f30000000000000000000000000000000000000000000000000000000000000009150610a1c565b600083111561092c5761010081049050600a830660300160f860020a0217600a83049250611877565b6118a8611acc565b6118b0611acc565b60008060206040518059106118c25750595b818152601f19601f830116810160200160405290509250600091505b602082101561196257506008810260020a84027fff00000000000000000000000000000000000000000000000000000000000000811615611957578083838151811061192657fe5b9060200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053505b6001909101906118de565b50909392505050565b611973611acc565b61197b611acc565b611983611acc565b61198b611acc565b611993611acc565b60008088955087945084518651016040518059106119ae5750595b818152601f19601f83011681016020016040529050935083925060009150600090505b8551811015611a42578581815181106119e657fe5b016020015160f860020a900460f860020a02838380600101945081518110611a0a57fe5b9060200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053506001016119d1565b5060005b8451811015611ab757848181518110611a5b57fe5b016020015160f860020a900460f860020a02838380600101945081518110611a7f57fe5b9060200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a905350600101611a46565b5090979650505050505050565b6000903b1190565b60206040519081016040526000815290565b815481835581811511611b0257600083815260209020611b02918101908301611b07565b505050565b61099891905b80821115610fdf5760008155600101611b0d5600a165627a7a72305820acd2f88c4266d21dc364824757dc3445dbd6bc4c15a90199e46a73d2a53ea2cf0029"}